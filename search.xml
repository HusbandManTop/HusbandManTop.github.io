<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Unity移动]]></title>
    <url>%2F2018%2F08%2F04%2FUnity%E7%A7%BB%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[Unity 移动 在Unity3d中,有很多方式可以改变物体的坐标,实现移动的目的,其本质是每一帧修改物体的Position; 1.通过Transfrom组件移动物体 Transfrom组件用于描述物体在空间中的状态,它包括 位置(Position),旋转(Rotation)和缩放(Scale). Transfrom.Translate该方法可以移动物体从当前位置,移动到指定位置,并且可以选择参照的坐标系. 当需要进行坐标系转换时,可以考虑使用1public void Translate(Vector 3 translation,Space relativeTo = Space.Self); 描述: 移动变换的方向和距离translation。如果relativeTo被忽略或设置为Space.Self，则运动将相对于变换的局部坐标轴应用。（在场景视图中选择对象时显示的x，y和z轴。）如果relativeTo是Space.World，则相对于世界坐标系应用该运动.123456789using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; void Update() &#123; transform.Translate(Vector3.forward * Time.deltaTime); transform.Translate(Vector3.up * Time.deltaTime, Space.World); &#125;&#125; 1public void Translate（float x，float y，float z， Space relativeTo = Space.Self; 描述: x沿着x轴，y沿着y轴和z沿着z轴移动变换。如果relativeTo被忽略或设置为Space.Self，则运动将相对于变换的局部坐标轴应用。（在场景视图中选择对象时显示的x，y和z轴。）如果relativeTo是Space.World，则相对于世界坐标系应用该运动。123456789using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; void Update() &#123; transform.Translate(0, 0, Time.deltaTime); transform.Translate(0, Time.deltaTime, 0, Space.World); &#125;&#125; 1public void Translate（Vector3 translation， Transform relativeTo）; 描述: 移动变换的方向和距离translation。该运动是相对于relativeTo本地坐标系应用的。如果relativeTo为null，则运动相对于世界坐标系应用。12345678using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; void Update() &#123; transform.Translate(Vector3.right * Time.deltaTime, Camera.main.transform); &#125;&#125; 1public void Translate（float x，float y，float z， Transform relativeTo）; 描述: x沿着x轴，y沿着y轴和z沿着z轴移动变换。该运动是相对于relativeTo本地坐标系应用的。如果relativeTo为null，则运动相对于世界坐标系应用。12345678using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; void Update() &#123; transform.Translate(Time.deltaTime, 0, 0, Camera.main.transform); &#125;&#125; Vector3Vector3.Lerp, Vector3.Slerp, Vector3.MoveTowards既可以表示三维空间中的一个点,也可以表示一个向量,这三个方法均为插值方法,Lerp为线性插值,Slerp为球形插值,MoveTowards在Lerp的基础上增加了限制最大速度的功能,当需要从指定A点移动到B点时,可以考虑使用这些方法;1public static Vector3 Lerp（Vector3 a， Vector3 b，float t） 描述: 在两个向量之间进行线性插值。在矢量a和插值之间b进行插值t。该参数t被钳位到范围[0，1]。这通常用于沿着两个端点之间的线找出点的一小部分（例如，在这些点之间逐渐移动一个对象）。当t= 0返回时a。当t= 1时返回b。当t= 0.5时返回中间点a和b。12345678910111213141516171819using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public Transform startMarker; public Transform endMarker; public float speed = 1.0F; private float startTime; private float journeyLength; void Start() &#123; startTime = Time.time; journeyLength = Vector3.Distance(startMarker.position, endMarker.position); &#125; void Update() &#123; float distCovered = (Time.time - startTime) * speed; float fracJourney = distCovered / journeyLength; transform.position = Vector3.Lerp(startMarker.position, endMarker.position, fracJourney); &#125;&#125; 1public static Vector3 Slerp（Vector3 a， Vector3 b，float t）; 描述: 在两个向量之间进行球形插值。在数量a和b数量之间进行插值t。这与线性插值（又名“lerp”）之间的区别在于矢量被视为方向而不是空间中的点。返回的矢量的方向是由内插的角度和它的 大小是的大小之间内插from和to。该参数t被钳位到范围[0，1]。123456789101112131415161718192021using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public Transform sunrise; public Transform sunset; public float journeyTime = 1.0F; private float startTime; void Start() &#123; startTime = Time.time; &#125; void Update() &#123; Vector3 center = (sunrise.position + sunset.position) * 0.5F; center -= new Vector3(0, 1, 0); Vector3 riseRelCenter = sunrise.position - center; Vector3 setRelCenter = sunset.position - center; float fracComplete = (Time.time - startTime) / journeyTime; transform.position = Vector3.Slerp(riseRelCenter, setRelCenter, fracComplete); transform.position += center; &#125;&#125; 1public static Vector3 MoveTowards（Vector3 current， Vector3 target，float maxDistanceDelta）; 描述: current向一个target点移动一条直线。该函数返回的值是maxDistanceDelta更接近于和target/ 之间的一个点的点单位。如果目标距离较近， 则返回的值将等于目标值（即，该移动不会超过目标）。可以使用负值来将点从目标推开。currenttargetmaxDistanceDelta/maxDistanceDelta1234567891011using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public Transform target; public float speed; void Update() &#123; float step = speed * Time.deltaTime; transform.position = Vector3.MoveTowards(transform.position, target.position, step); &#125;&#125; Vector3.SmoothDamp该方法是可以平滑的从A逐渐移动到B点，并且可以控制速度，最常见的用法是相机跟随目标。1public static Vector3 SmoothDamp（Vector3 current， Vector3 target，ref Vector3 currentVelocity，float smoothTime，float maxSpeed = Mathf.Infinity，float deltaTime = Time.deltaTime）; current: 当前位置 target: 需要达到的目标位置 currentVelocity: 当前的速度,每次调用该函数值都会被该函数修改 smoothTime: 到达目标位置需要的时间,较小的值将更快到达目标位置 maxSpeed: 选择性的允许限制最大虚度 deltaTime: 帧间隔时间123456789101112using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public Transform target; public float smoothTime = 0.3F; private Vector3 velocity = Vector3.zero; void Update() &#123; Vector3 targetPosition = target.TransformPoint(new Vector3(0, 5, -10)); transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref velocity, smoothTime); &#125;&#125; TransformTransform.position世界空间变换的位置 下面的例子通过更新位置使一个附加的球体反弹。这种反弹慢慢地结束了。这个位置也可以用来确定三维空间中的变换。1234567891011121314151617181920212223242526272829303132using UnityEngine;// Use Transform.position to bounce a sphere.// The sphere and a quad are colored using materials.public class ExampleScript : MonoBehaviour&#123; Vector3 velocity = new Vector3(0.0f, 1.0f, 0.0f); float floorHeight = 0.0f; float sleepThreshold = 0.05f; float gravity = -9.8f; void Start() &#123; transform.position = new Vector3(0.0f, 1.5f, 0.0f); &#125; void FixedUpdate() &#123; if (velocity.magnitude &gt; sleepThreshold || transform.position.y &gt; floorHeight) &#123; velocity += new Vector3(0.0f, gravity * Time.fixedDeltaTime, 0.0f); &#125; transform.position += velocity * Time.fixedDeltaTime; if (transform.position.y &lt;= floorHeight) &#123; transform.position = new Vector3(0.0f, floorHeight, 0.0f); velocity.y = -velocity.y; &#125; &#125;&#125; 通过Rigidbody组件移动物体Rigidbody组件用于模拟物体的物理状态，比如物体受重力影响，物体被碰撞后的击飞等等。Rigidbody组件用于模拟物体的物理状态，比如物体受重力影响，物体被碰撞后的击飞等等。注意：关于Rigidbody的调用均应放在FixedUpdate方法中，该方法会在每一次执行物理模拟前被调用。Unity5更改：是rigidbody变量未定义为Rigidbody类型，所以提示rigidbody无法访问velocity。Rigidbody都要定义一个变量(Rigidbody rigidbody;)，然后让该变量指向Rigidbody组件才能访问 rigidbody =GetComponent (); Rigidbody.velocity 设置刚体速度可以让物体运动并且忽略静摩擦力，这会让物体快速从静止状态进入运动状态。 在大多数情况下，不应该直接修改速度，因为这会导致不切实际的行为。不要在每个物理步骤设置对象的速度，这会导致不切实际的物理模拟123456789101112131415161718using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour&#123; public Rigidbody rb; void Start() &#123; rb = GetComponent&lt;Rigidbody&gt;(); &#125; void FixedUpdate() &#123; if (Input.GetButtonDown("Jump")) rb.velocity = new Vector3(0, 10, 0); &#125;&#125; Rigidbody.AddForce1public void AddForce（Vector3 force， ForceMode mode = ForceMode.Force）; 给Rigidbody增加一个力量。 沿force矢量方向连续施加力。指定ForceMode mode可以将力的类型更改为加速度，脉冲或速度变化。力量只能应用于活动的刚体。如果GameObject处于非活动状态，则AddForce不起作用。默认情况下，一旦施加力，刚体的状态就设置为醒来，除非力是Vector3.zero。1234567891011121314151617using UnityEngine;public class ExampleClass : MonoBehaviour&#123; public float thrust; public Rigidbody rb; void Start() &#123; rb = GetComponent&lt;Rigidbody&gt;(); &#125; void FixedUpdate() &#123; rb.AddForce(transform.forward * thrust); &#125;&#125; Rigidbody.MovePosition刚体受到物理约束的情况下，移动到指定点1public void MovePosition（Vector3 position）; 移动刚体position。使用Rigidbody.MovePosition移动刚体，符合刚体的插值设置。如果在Rigidbody上启用了Rigidbody插值，调用Rigidbody.MovePosition会导致渲染的任何中间帧中两个位置之间的平滑过渡。如果要在每个FixedUpdate中连续移动刚体，则应该使用此选项123456789101112131415161718using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour&#123; public Vector3 teleportPoint; public Rigidbody rb; void Start() &#123; rb = GetComponent&lt;Rigidbody&gt;(); &#125; void FixedUpdate() &#123; rb.MovePosition(transform.position + transform.forward * Time.deltaTime); &#125;&#125; 通过CharacterController组件移动物体CharacterController用于控制第一人称或第三人称角色的运动，使用这种方式可以模拟人的一些行为，比如限制角色爬坡的最大斜度,步伐的高度等。 CharacterController.SimpleMove用于模拟简单运动，并且自动应用重力，返回值表示角色当前是否着地。1public bool SimpleMove（Vector3 speed）; 移动角色speed。沿y轴的速度被忽略。速度以米/秒为单位。重力是自动应用的。如果角色接地，则返回。建议您每帧仅对Move或SimpleMove进行一次调用。1234567891011121314using UnityEngine;using System.Collections;[RequireComponent(typeof(CharacterController))]public class ExampleClass : MonoBehaviour &#123; public float speed = 3.0F; public float rotateSpeed = 3.0F; void Update() &#123; CharacterController controller = GetComponent&lt;CharacterController&gt;(); transform.Rotate(0, Input.GetAxis("Horizontal") * rotateSpeed, 0); Vector3 forward = transform.TransformDirection(Vector3.forward); float curSpeed = speed * Input.GetAxis("Vertical"); controller.SimpleMove(forward * curSpeed); &#125;&#125; CharacterController.Move模拟更复杂的运动,重力需要通过代码实现，返回值表示角色与周围的碰撞信息。1public CollisionFlags Move(Vector3 motion); 一个更复杂的移动功能，采取绝对移动增量。试图通过移动控制器motion，运动只会受到碰撞的限制。它会沿着对撞机滑动。 CollisionFlags是移动过程中发生的碰撞汇总。此功能不适用于任何重力12345678910111213141516171819202122using UnityEngine;using System.Collections;public class ExampleClass : MonoBehaviour &#123; public float speed = 6.0F; public float jumpSpeed = 8.0F; public float gravity = 20.0F; private Vector3 moveDirection = Vector3.zero; void Update() &#123; CharacterController controller = GetComponent&lt;CharacterController&gt;(); if (controller.isGrounded) &#123; moveDirection = new Vector3(Input.GetAxis("Horizontal"), 0, Input.GetAxis("Vertical")); moveDirection = transform.TransformDirection(moveDirection); moveDirection *= speed; if (Input.GetButton("Jump")) moveDirection.y = jumpSpeed; &#125; moveDirection.y -= gravity * Time.deltaTime; controller.Move(moveDirection * Time.deltaTime); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoogleAdMob广告接入]]></title>
    <url>%2F2018%2F08%2F04%2FGoogleAdMob%E5%B9%BF%E5%91%8A%E6%8E%A5%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Google AdMob接入 添加Google AdMob步骤 注册长号(要越枪) 登录 进入Monetize 创建App 创建Ad unit(注意Ad unit ID) 下载Unity插件导入 在代码中调试广告 创建广告ID及SDK下载 初始化MobileAds官方文档给出的说法: 在加载广告之前，让您的应用程序通过MobileAds.Initialize()使用您的AdMob 应用程序ID进行调用来初始化Mobile Ads SDK 。这只需要完成一次，理想情况下应用程序启动。您可以在AdMob用户界面中找到您应用的应用ID。12345678910111213141516171819...using GoogleMobileAds.Api;...public class GoogleMobileAdsDemoScript : MonoBehaviour&#123; public void Start() &#123; #if UNITY_ANDROID string appId = "ca-app-pub-3940256099942544~3347511713"; #elif UNITY_IPHONE string appId = "ca-app-pub-3940256099942544~1458002511"; #else string appId = "unexpected_platform"; #endif // Initialize the Google Mobile Ads SDK. MobileAds.Initialize(appId); &#125;&#125; 创建横幅式广告横幅广告是矩形图片或文字广告，占据屏幕上的一个点。当用户与应用程序进行交互时，它们会保持在屏幕上，并且可以在一段时间后自动刷新1234567891011121314151617181920212223242526...using GoogleMobileAds.Api;...public class GoogleMobileAdsDemoScript : MonoBehaviour&#123; private BannerView bannerView; … public void Start() &#123; this.RequestBanner(); &#125; private void RequestBanner() &#123; #if UNITY_ANDROID string adUnitId = "ca-app-pub-3940256099942544/6300978111"; #elif UNITY_IPHONE string adUnitId = "ca-app-pub-3940256099942544/2934735716"; #else string adUnitId = "unexpected_platform"; #endif // Create a 320x50 banner at the top of the screen. bannerView = new BannerView(adUnitId, AdSize.Banner, AdPosition.Top); &#125;&#125; BannerView构造函数参数: adUnitId- BannerView应从中加载广告的AdMob广告单元ID 。 AdSize- 您要使用的AdMob广告尺寸（详情请参阅横幅尺寸）。 AdPosition - 横幅广告应放置的位置。该 AdPosition枚举列出了有效的广告位置值其他方式请参考:官方文档]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AssetBundle基础篇]]></title>
    <url>%2F2018%2F08%2F04%2FAssetBundle%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[AssetsBundle基础篇(一) Unity 之 AssetsBundle官方文档 AssetsBundle的定义和作用 AssetsBundle是一个压缩包,包含模型/贴图/预制体/声音/甚至整个场景,可以在游戏运行的时候被加载; AssetsBundle自身保存着相互依赖的关系; 压缩包可以使用LZMA和LZ4压缩算法,减少包大小,更快的进行网络传输; LZMA: LZ4: 把一些可以下载的内容放在AssetsBundle里面,可以减少安装包的大小;什么是AssetsBundle 它是一个存在于硬盘上的文件,可以称为压缩包,这个压缩包可以认为是一个文件夹,里面包含了很多个文件,这些文件可以分为两类: serialized file(序列化文件) serialized file:资源被打碎放在一个对象中,最后统一被写进一个单独的文件(只有一个) resource file(源文件) resource file:某些二进制资源(图片,声音)被单独保存,方便快速加载 它是一个AssetsBundle对象,我们可以通过代码从一个特定的压缩包加载出来的对象,这个对象包含了所有我们当初添加到这个压缩包里面的内容,我们可以通过这个对象加载出来使用 AssetsBundle使用流程 指定资源的AssetsBundle属性 指定要打包的物品的AssetsBundle名字和后缀(在指定AB包名字的时候可以直接自定义目录AssetScene/AssetsBundle)当AssetsBundle包多的时候可以进行目录结构的划分 构建AB包(打包AssetsBundle包) 构建AB包的脚本一般都是在Editor模式下运行;123456789101112 [MenuItem("MyTools/BuildBundles")]public static void BuildBundles()&#123; string buildPath = Application.dataPath + "/AssetsBundles"; if(Directory.Exists(buildPath) == false) &#123; Directory.CreateDirectory(buildPath); &#125; //构建AB包 BuildPipeline.BuildAssetBundles(buildPath, BuildAssetBundleOptions.None, BuildTarget.Android); AssetDatabase.Refresh();&#125; 上传AB包(把AssetsBundle包上传到服务器) 加载AB包里面的资源12345678910111213void Start () &#123; loadPath = Application.dataPath + "/AssetsBundles/scene/cube.unityasset"; LoadAsset();&#125;void LoadAsset()&#123; //加载AssetsBundle包 AssetBundle ab = AssetBundle.LoadFromFile(loadPath); //从AssetsBundle包取得资源 GameObject cube = ab.LoadAsset&lt;GameObject&gt;("Cube"); Instantiate(cube);&#125; AssetsBundle的打包参考分组策略 逻辑实体分组 一个UI界面或者所以得UI界面打成一个包(这个界面里面的贴图和布局信息一个包) 一个角色或者所有角色一个包(这个角色里面的模型/动画一个包) 所有场景所共享的部分打成打一个包(包括贴图和模型) 按照类型分组 所有声音资源打成一个包,所有Shader打成一个包,所有模型打成一个包,所有材质打成一个包 按照使用分组 把某一时间内使用的所有资源打成一个包.可以按照关卡分,一个关卡所需要的所有资源包括角色/贴图/声音等打成打一个包;也可以按照场景划分,一个场景所需要的资源一个包 分组策略 把经常更新的资源放在一个单独的包里面,跟不经常更新的资源分离 把需要同时加载的资源放在一个包里面 可以把其他包共享的资源放在一个单独的包里面(根据依赖关系打包,减少重复打包重复资源,减小AB包大小) 把一些需要同时加载的小资源打包成一个包 如果对于一个同一个资源有两个版本,可以考虑通过后缀来区分 AssetBundle压缩方式BuildAssetBundles(paramter 1,paramter 2,paramter 3); paramter 1: build的路径(任意本地路径) paramter 2: BuildAssetsBundleOptions: BuildAssetsBundleOptions.None: 使用LZMA算法,压缩包更小,但是加载时间更长.使用之前需要整体解压,一旦被解压,这个包会使用LZ4算法重新压缩.使用资源的时候不需要整体解压.在下载的时候可以使用LZMA算法,一旦被下载了之后,它会使用LZ4算法保存到本地; BuildAssetsBundleOptions.UncompressedAssetBundle: 不使用压缩,包体大,但是加载速度快; BuildAssetsBundleOptions.ChunkBasedCompression: 使用LZ4算法压缩,压缩率没有LZMA高,但是我们可以加载指定资源而不用解压全部 注意:使用LZ4压缩,可以获得跟不压缩相媲美的加载速度,而且比不压缩文件包体要小 - paramter 3: 构建平台,不同平台构建出来的包会有差异;##### Manifest文件- CRC: 文件校验码- Assets: Assetbundle包含的资源- Dependencies: 依赖的资源路径##### 资源的依赖关系- 如果一个或多个AssetBundle UnityEngine.Objects包含对UnityEngine.Object位于另一个包中的引用，则AssetBundles可以依赖于其他AssetBundle 。如果UnityEngine.Object包含对UnityEngine.Object不包含在任何AssetBundle 中的引用，则不会发生依赖关系。在这种情况下，在构建AssetBundle时，捆绑包所依赖的对象的副本将复制到捆绑包中。如果多个捆绑包中的多个对象包含对未分配到捆绑包的同一对象的引用，则每个对该对象具有依赖关系的捆绑包都将生成其自己的对象副本并将其打包到构建的AssetBundle中。- 如果一个AssetBundle包含一个依赖项，那么在你试图实例化的对象被加载之前，加载包含这些依赖项的包是很重要的。Unity不会尝试自动加载依赖关系。before loading the Material from Bun- before loading the Material from Bundle 1, you would need to load Bundle 2 into memory. It does not matter which order you load Bundle 1 and Bundle 2, the important takeaway is that Bundle 2 is loaded before loading the Material from Bundle 1. In the next section, we’ll discuss how you can use the AssetBundleManifest objects we touched on in the previous section to determine, and load, dependencies at runtime.(在从Bundle 1加载材料之前，需要将Bundle 2加载到内存中。加载Bundle 1和Bundle 2的顺序无关紧要，重要的是Bundle 2在加载Bundle 1的材料之前就已经加载好了) 加载AssetsBundle加载https://docs.unity3d.com/2017.4/Documentation/Manual/AssetBundles-Native.html AssetBundle.LoadFromMemory(); //内存加载方式 AssetBundle.LoadFromFile(); //文件加载方式 从本地存储装载未压缩的包时，此API非常高效。如果捆绑包未压缩或压缩块（LZ4），LoadFromFile将直接从磁盘加载捆绑包。使用此方法加载完全压缩（LZMA）捆绑包将首先解压缩捆绑包，然后再将其加载到内存中1234567891011public class LoadFromFileExample extends MonoBehaviour &#123; function Start() &#123; var myLoadedAssetBundle AssetBundle.LoadFromFile(Path.Combine(Application.streamingAssetsPath, "myassetBundle")); if (myLoadedAssetBundle == null) &#123; Debug.Log("Failed to load AssetBundle!"); return; &#125; var prefab = myLoadedAssetBundle.LoadAsset.&lt;GameObject&gt;("MyObject"); Instantiate(prefab); &#125;&#125; AssetBundle.LoadFromFileAsync();//文件异步加载方式该函数接收包含AssetBundle数据的字节数组。也可以根据需要传递CRC值。如果捆绑包是LZMA压缩的，它将在加载时解压缩AssetBundle。LZ4压缩束以其压缩状态加载. 12345678910IEnumerator LoadFromMemoryAsync(string path)&#123; AssetBundleCreateRequest createRequest = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path)); yield return createRequest; AssetBundle bundle = createRequest.assetBundle; var prefab = bundle.LoadAsset.&lt;GameObject&gt;("MyObject"); Instantiate(prefab);&#125; WWW.LoadFromCacheOrDownload(); //从服务器或者本地加载(不在推荐的API)此API对于从远程服务器下载AssetBundles或加载本地AssetBundles 12345678910111213141516171819public class LoadFromCacheOrDownloadExample : MonoBehaviour&#123; IEnumerator Start () &#123; while (!Caching.ready) &#123; yield return null; &#125; var www = WWW.LoadFromCacheOrDownload("http://myserver.com/myassetBundle", 5); yield return www; if(!string.IsNullOrEmpty(www.error)) &#123; Debug.Log(www.error); yield return; &#125; var myLoadedAssetBundle = www.assetBundle; var asset = myLoadedAssetBundle.mainAsset; &#125;&#125; UnityWebRequest //web加载(支持Unity5.3+)UnityWebRequest有一个特定的API调用来处理AssetBundles。首先，需要使用创建网络请求UnityWebRequest.GetAssetBundle。在返回请求之后，将请求对象传入DownloadHandlerAssetBundle.GetContent(UnityWebRequest)。此GetContent调用将返回您的AssetBundle对象。也可以在下载捆绑包后assetBundle以DownloadHandlerAssetBundle类的属性加载AssetBundle，其效率为AssetBundle.LoadFromFile 123456789101112131415IEnumerator InstantiateObject() &#123; string uri = "file:///" + Application.dataPath + "/AssetBundles/" + assetBundleName; UnityEngine.Networking.UnityWebRequest request = UnityEngine.Networking.UnityWebRequest.GetAssetBundle(uri, 0); yield return request.Send(); AssetBundle bundle = DownloadHandlerAssetBundle.GetContent(request); //还可以 AssetsBundle ab = (request.downloadHandler as DownloadHandlerAssetBundle).assetBundle; GameObject cube1 = ab.LoadAsset&lt;GameObject&gt;("Cube1"); GameObject cube = bundle.LoadAsset&lt;GameObject&gt;("Cube"); GameObject sprite = bundle.LoadAsset&lt;GameObject&gt;("Sprite"); Instantiate(cube); Instantiate(sprite); &#125; AssetBundleManifest文件加载123456789AssetBundle assetBundle = AssetBundle.LoadFromFile(manifestFilePath);AssetBundleManifest manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;("AssetBundleManifest");//获取这个包所以依赖的包的包名string[] dependencies = manifest.GetAllDependencies("assetBundle"); //Pass the name of the bundle you want the dependencies for.传递想要依赖项的包的名称。foreach(string dependency in dependencies)&#123; //遍历包名去加载需要的包 AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependency));&#125; AssetsBundle卸载 减少内存的使用(从活动场景中移除时，Unity不会自动卸载对象) 可能导致丢失(不正确地卸载AssetBundle可能导致在内存中复制对象或其他不合需要的情况，例如缺少纹理)什么时候去卸载资源 AssetsBundle.Unload(true): 卸载从AssetBundle加载的所有GameObjects（及其依赖项）。这不包括复制的GameObjects（例如实例化的GameObjects），因为它们不再属于AssetBundle。发生这种情况时，从该资产包中加载（并且仍属于它）的纹理从场景中的GameObjects中消失，并且Unity将它们视为缺失的纹理。 AssetsBundle.Unload(false): 卸载所有没有被使用的资源 如果AB.Unload（true）被调用。活动场景中的任何M实例也将被卸载并销毁。如果改为调用AB.Unload（false），它会打破M和AB当前实例的关联。如果稍后再次加载AB并调用AB.LoadAsset（），Unity将不会将M的现有副本重新链接到新加载的材质。反而会有两个M加载的副本。 Generally, using AssetBundle.Unload(false) does not lead to an ideal situation. Most projects should use AssetBundle.Unload(true) to keep from duplicating objects in memory. Most projects should use AssetBundle.Unload(true) and adopt a method to ensure that Objects are not duplicated. Two common methods are: Having well-defined points during the application’s lifetime at which transient AssetBundles are unloaded, such as between levels or during a loading screen. Maintaining reference-counts for individual Objects and unload AssetBundles only when all of their constituent Objects are unused. This permits an application to unload &amp; reload individual Objects without duplicating memory. If an application must use AssetBundle.Unload(false), then individual Objects can only be unloaded in two ways: Eliminate all references to an unwanted Object, both in the scene and in code. After this is done, call Resources.UnloadUnusedAssets. Load a scene non-additively. This will destroy all Objects in the current scene and invoke Resources.UnloadUnusedAssets automatically. If you’d rather not manage loading Asset Bundes, dependencies, and Assets yourself, you might find yourself in need of the AssetBundle Manager. 文件校验CRC/ MD5/ SHA1 相同点 CRC/ MD5/ SHA1都是通过对数据进行计算,来生成一个校验值,该校验值用来校验数据的完整性 不同点 算法不同:CRC采用多项式除法,MD5和SHA1使用的是替换,轮转等方法 校验值长度不同: CRC校验的长度跟其多项式有关系,一般为16或者32位,MD5是16字节(128位),SHA1是20个字节(160位) 校验值的称呼不同: CRC一般称为CRC值;MD5和SHA1一般叫做哈希值或者散列值; 安全性不同: 指的是检错的能力,即数据的错误能通过校验位检测出来,CRC的安全性跟多项式有很大关系,相对于MD5和SHA1要弱很多;MD5的安全性很搞(不过已经被破解了);SHA1的安全性最高; 效率不同: CRC的效率很高,MD5和SHA1比较慢 用途不同: CRC一般用作通讯数据检验,MD5和SHA1用于安全领域,比如文件校验,数字签名]]></content>
      <categories>
        <category>热更新</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>热更新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bmob支付]]></title>
    <url>%2F2018%2F08%2F04%2FBmob%E6%94%AF%E4%BB%98%2F</url>
    <content type="text"><![CDATA[Bmob支付 移动应用后端云服务(http://bmob.cn) 提供的产品: ios和Android云数据库 ios和Android支付 ios和Android聊天组件 cocos2d-x SDK云数据库 Unity云数据库 ios和Android短信 JavaScript SDK云数据库]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BlendTree]]></title>
    <url>%2F2018%2F08%2F04%2FBlendTree%2F</url>
    <content type="text"><![CDATA[动画状态机(混合树)]]></content>
      <categories>
        <category>MecanimAnimator</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>MecanimAnimator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnityAPS广告系统]]></title>
    <url>%2F2018%2F08%2F04%2FUnityAPS%E5%B9%BF%E5%91%8A%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[UnityAPS unity官方广告平台UnityAPS官网]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UnityAPI解析]]></title>
    <url>%2F2018%2F08%2F04%2FUnityAPI%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[UnityAPI文档Unity圣典Unity官方手册蛮牛手册 API(Application Programming Interface),即应用程序编程接口,是一些预定义的函数,目的是提供应用程序与开发人员基于某软件或者硬件得以访问一组例程的能力,而无需访问源码,或去理解内部工作机制细节 Unity 脚本事件函数执行顺序和生命周期: 第一章: Application类Application类不含实例属性和实例方法,在脚本中通过直接调用Application类的静态属性和方法来控制程序的运行时的数据;Application静态属性: 1.dataPath属性: 数据文件路径 {public static string dataPath{get;}} 2.Application.dataPath: 返回程序的数据文件所在文件夹的路径(只读).返回路径为相对路径,不同游戏平台的数据文件保存路径不同; 3.Application.PersistentDataPath: 返回一个持久化数据存储目录的路径(只读),可以在此路径下存储一些持久化的数据文件.同一平台,不同程序中调用此属性,返回值相同. 4.Application.streamingAssetsPath: 此属性用于返回流数据的缓存目录,返回路径为相对路径,适合设置一些外部文件的路径. 5.Application.temporaryCachePath: 此属性用于返回一个临时数据目录(只读),对于同一平台,不同程序调用此属性,返回值相同.loadedLevel属性 : 关卡索引 1.public static int loadedLevel{ get; } 2.Application.loadedLevel 返回当前场景的索引值 3.Application.loadedLevelName 返回当前场景的名字 4.Application.isLoadingLevel 是否有场景被加载 5.Application.LevelCount 游戏中可被加载的场景数量 6.Application.platform 当前游戏的运行平台,返回值为枚举类型 7.Application.isPlaying 当前游戏是否正在运行 8.Application.isEditor 游戏是否处于Unity编辑模式Application类静态方法: 1.CaptureScreenshot方法 : 截屏 2.public static void CaptureScreenshot(string filename); 3.public static void CaptureScreenshot(string filename, int superSize); 参数filename 截屏文件名称 superSize放大系数,默认为0,即不放大 此方法截取当前游戏画面并保存为PNG格式,文件默认保存在根目录下,若有重名文件则替换. 4.LoadLevelAdditiveAsync方法 : 异步加载关卡 5.public static AsynvOperation LoadLevelAdditiveAsync(int index);//参数关卡索引值 6.public static AsynvOperation LoadLevelAdditiveAsync(string levelName);//参数关卡名称 此方法用于按照关卡名字在后台异步加载关卡到当前场景中,此方法只是将新关卡加载到当前场景,当前场景的原有内容不会被销毁. 7.AsynvOperation colve = public static AsynvOperation &gt;&gt;LoadLevelAdditiveAsync(int index); 8.colve.isDone 是否加载完成 9.colve.progress 加载进度 10.RegisterLogCallback方法 :注册委托 public static void RegisterLogCallback(Application.LogCallback handler);参数是委托的名字 此方法用于注册一个委托来调用日志信息 Animator.StringToHash 字符串转换为哈希值1public static int StringToHash(string name) Parameters参数: - name The string to convert to id(该字符串转换到id); Generates an parameter id fron a string: - 从字符串生成一个参数ID Ids are used for optimized setters and getters on parameters当使用Animator时,如果要引用某个状态或者参数,有两种方法: 1.通过字符串名称 2.通过整数”Hash Id” 通过”Hush Id”更有优势,因为不容易出错,且更加高效,两种的使用方式不同 Animation状态或者Parameters的字符串(Tag)需要通过对象使用;但是”Hush Id”不惜要,它是Animator的静态方法; 12345678910111213141516public class Animas : MonoBehaciour&#123; //字符串转换为哈希值 private int speedId = Animator.StringToHash("Speed"); private Animator anim; void Start() &#123; anim = GetCompent&lt;Animator&gt;(); &#125; void Update() &#123; anim.SetFloat(speedId,Input.GetAxis("Vertival")); &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity异步加载场景]]></title>
    <url>%2F2018%2F08%2F04%2FUnity%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[Unity异步加载 协同程序的异步加载: 协同程序是在主线程序运行的时间内,同时开启另一段逻辑的处理来协助当前程序的执行(开启协程就是开启一段可以与主线程并行的逻辑); 为什么异步加载 为了节省内存，游戏的一些资源往往需要在运行时（runtime）动态加载。如果资源本身加载比较耗时，采用同步方法会产生卡顿现象，对此的解决方法通常采用多线程或者使用引擎本身自带的异步加载方法。在Unity开发中，由于一些方法（如Resources.Load）本身不支持在其它线程调用，因此多线程的使用会受到限制；而Unity脚本API对许多加载方式都有相应的异步方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class Loading : MonoBehaviour &#123; public Slider loadingSlider; private int currentProgress;//当前进度 0-1 private int toProgress;//加载进度 //定义异步操作 private AsyncOperation async; private void Start() &#123; StartCoroutine(LoadScene()); &#125; IEnumerator LoadScene() &#123; //异步加载场景 async = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(2); async.allowSceneActivation = false;//默认异步加载是不被开启 yield return async; &#125; private void Update() &#123; if (async == null) return; if(async.progress &lt; 0.9f) &#123; toProgress = (int)async.progress * 100; &#125;else &#123; toProgress = 100; &#125; if(currentProgress &lt; toProgress ) &#123; currentProgress++; &#125; loadingSlider.value = currentProgress / 100f; if(currentProgress == 100) &#123; //加载完成后激活异步加载 async.allowSceneActivation = true; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EasyAR对焦]]></title>
    <url>%2F2018%2F08%2F04%2FEasyAR%E5%AF%B9%E7%84%A6%2F</url>
    <content type="text"><![CDATA[EasyAR相机对焦 1.直接在EasyAR_Startup下面的CameraDevice身上的CameraDeviceBehaviour 脚本上面写就行了; 2.EasyAR官网给出的API介绍: 3.这个是CameraDeviceBaseBehaviour里面的函数: 4.可以去看下,里面的其他功能也可以根据需要去调用实现CameraDeviceBaseBehaviour里面的函数:123456789101112namespace EasyAR&#123; public class CameraDeviceBehaviour : CameraDeviceBaseBehaviour &#123; protected override void Start() &#123; base.Start(); SetFocusMode(FocusMode.Continousauto);//连续自动对焦模式 &#125; &#125;&#125;]]></content>
      <categories>
        <category>AR</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuforia对焦]]></title>
    <url>%2F2018%2F08%2F04%2FVuforia%E5%AF%B9%E7%84%A6%2F</url>
    <content type="text"><![CDATA[VuforiaAR 相机对焦 做AR的是经常会用到相机对焦功能,就记录下来,方便以后查询:1234567891011121314151617181920212223242526272829303132333435private void Start()&#123; var vuforia = VuforiaARController.Instance; vuforia.RegisterVuforiaStartedCallback();//Vuforia的回调函数&#125;/// &lt;summary&gt;/// 自动对焦模式/// &lt;/summary&gt;private void OnVuforiaStarted()&#123; CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO);//1.FocusMode.FOCUS_MODE_TRIGGERAUTO对焦一次&#125;/// &lt;summary&gt;/// 切换前后相机/// &lt;/summary&gt;private void SwitchCameraDirection()&#123; CameraDevice.Instance.Stop();//停止当前相机 CameraDevice.Instance.Deinit();//取消初始化 CameraDevice.Instance.Init(CameraDevice.CameraDirection.CAMERA_FRONT);//初始化相机 CameraDevice.Instance.Start();//打开相机&#125;/// &lt;summary&gt;///打开闪光灯/// &lt;/summary&gt;private void TurnOnFlash(bool ON)&#123; CameraDevice.Instance.SetFlashTorchMode(ON);&#125;]]></content>
      <categories>
        <category>AR</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不用第三变量交换两个变量的值]]></title>
    <url>%2F2018%2F08%2F04%2F%E4%B8%8D%E7%94%A8%E7%AC%AC%E4%B8%89%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[C#不使用第三变量交换两个变量的值 1.算术运算12345678910简单来说，就是通过普通的+和-运算来实现。代码如下： int a,b; a=10;b=12; a=b-a; //a=2;b=12 b=b-a; //a=2;b=10 a=b+a; //a=10;b=10通过以上运算，a和b中的值就进行了交换。表面上看起来很简单，但是不容易想到，尤其是在习惯标准算法之后。 它的原理是：把a、b看做数轴上的点，围绕两点间的距离来进行计算。 具体过程：第一句“a=b-a”求出ab两点的距离，并且将其保存在a中；第二句“b=b-a”求出a到原点的距离（b到原点的距离与ab两点距离之差），并且将其保存在b中；第三句“a=b+a”求出b到原点的距离（a到原点距离与ab两点距离之和），并且将其保存在a中。完成交换。 此算法与标准算法相比，多了三个计算的过程，但是没有借助临时变量。（以下称为算术算法） 2.位运算1234567通过异或运算也能实现变量的交换，这也许是最为神奇的，请看以下代码： int a=10,b=12; //a=1010^b=1100; a=a^b; //a=0110^b=1100; b=a^b; //a=0110^b=1010; a=a^b; //a=1100=12;b=1010; 此算法能够实现是由异或运算的特点决定的，通过异或运算能够使数据中的某些位翻转，其他位不变。这就意味着任意一个数与任意一个给定的值连续异或两次，值不变。 即：a^b^b=a。将a=a^b代入b=a^b则得b=a^b^b=a;同理可以得到a=b^a^a=b;轻松完成交换。 3.指针修改内存地址1234567891011121314151617181920212223因为对地址的操作实际上进行的是整数运算，比如：两个地址相减得到一个整数，表示两个变量在内存中的储存位置隔了多少个字节；地址和一个整数相加即“a+10”表示以a为基地址的在a后10个a类数据单元的地址。所以理论上可以通过和算术算法类似的运算来完成地址的交换，从而达到交换变量的目的。即： int *a,*b; //假设 *a=new int(10); *b=new int(20); //&amp;a=0x00001000h,&amp;b=0x00001200h a=(int*)(b-a); //&amp;a=0x00000200h,&amp;b=0x00001200h b=(int*)(b-a); //&amp;a=0x00000200h,&amp;b=0x00001000h a=(int*)(b+int(a)); //&amp;a=0x00001200h,&amp;b=0x00001000h 通过以上运算a、b的地址真的已经完成了交换，且a指向了原先b指向的值，b指向原先a指向的值了吗？上面的代码可以通过编译，但是执行结果却令人匪夷所思！原因何在？ 首先必须了解，操作系统把内存分为几个区域：系统代码/数据区、应用程序代码/数据区、堆栈区、全局数据区等等。在编译源程序时，常量、全局变量等都放入全局数据区，局部变量、动态变量则放入堆栈区。这样当算法执行到“a=(int*)(b-a)”时，a的值并不是0x00000200h，而是要加上变量a所在内存区的基地址，实际的结果是：0x008f0200h，其中0x008f即为基地址，0200即为a在该内存区的位移。它是由编译器自动添加的。因此导致以后的地址计算均不正确，使得a,b指向所在区的其他内存单元。再次，地址运算不能出现负数，即当a的地址大于b的地址时，b-a&lt;0，系统自动采用补码的形式表示负的位移，由此会产生错误，导致与前面同样的结果。 有办法解决吗？当然！以下是改进的算法： if(a &#123; a=(int*)(b-a); b=(int*)(b-(int(a)&amp;0x0000ffff)); a=(int*)(b+(int(a)&amp;0x0000ffff)); &#125; else &#123; b=(int*)(a-b); a=(int*)(a-(int(b)&amp;0x0000ffff)); b=(int*)(a+(int(b)&amp;0x0000ffff)); &#125; 算法做的最大改进就是采用位运算中的与运算“int(a)&amp;0x0000ffff”，因为地址中高16位为段地址，后16位为位移地址，将它和0x0000ffff进行与运算后，段地址被屏蔽，只保留位移地址。这样就原始算法吻合，从而得到正确的结果。]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity获取设备分辨率]]></title>
    <url>%2F2018%2F08%2F04%2FUnity%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E5%88%86%E8%BE%A8%E7%8E%87%2F</url>
    <content type="text"><![CDATA[Unity获取设备分辨率 1234567public class ExampleClass : MonoBehaviour &#123; void Start() &#123; Resolution[] resolutions = Screen.resolutions; //设置分辨率 Screen.SetResolution(resolutions[0].width, resolutions[0].height, true); &#125; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity创建解析Json]]></title>
    <url>%2F2018%2F08%2F04%2FUnity%E5%88%9B%E5%BB%BA%E8%A7%A3%E6%9E%90Json%2F</url>
    <content type="text"><![CDATA[Json操作 两种方式: 一.LitJson 二.Unity自带的解析类:JsonUtility 1.Josn的描述 {“key”:”val”,”key”,”val”} //{“name”:”张三”,”age”:”18”} Json中{} == C#中的对象 Json中[] == C#中的数组 123456789101112131.(json)[1,2,3] == (C#)int[]2.(json)[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;] == (C#)string[]3.(json)[&#123;&quot;name&quot;:&quot;Lili&quot;&#125;,&#123;&quot;age&quot;:&quot;16&quot;,&#123;&quot;gender&quot;:&quot;girl&quot;&#125;&#125;, &#123;&quot;name&quot;:&quot;dashan&quot;&#125;,&#123;&quot;age&quot;:&quot;18&quot;,&#123;&quot;gender&quot;:&quot;boy&quot;&#125;&#125;] == (C#)Person[]Class Person&#123; string name; int age; string gender;&#125; 1.1 使用JSonUtility创建Json123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void CreatJson() &#123; //&#123;"name":"Lili" , "age":20 &#125; Person p1 = new Person(); p1.name = "Lili"; p1.age = 20; //转换为Json字符串 string jsonStr = JsonUtility.ToJson(p1); /*------------------------------------*/ /*&#123;"Person": * [ * &#123; * "name" : "hehe", * "age" : 34, * "gender" : "boy" * &#125;, * &#123; * "name" : "dada", * "age" : 19, * "gender" : "girl" * &#125; * ] * &#125; */ Person p2 = new Person(); p2.name = "hehe"; p2.age = 34; p2.gender = "boy"; Person p3 = new Person(); p3.name = "dada"; p3.age = 19; p3.gender = "girl"; Person[] ps = new Person[] &#123; p2, p3 &#125;; Persons pers = new Persons(); pers.persons = ps; jsonStr = JsonUtility.ToJson(pers); print(jsonStr); &#125;&#125;[Serializable]//要跟Json之间相互转换需要先序列化public class Person&#123; public string name; public int age; public string gender;&#125;[Serializable]public class Persons&#123; public Person[] persons;&#125; 1.2 使用JSonUtility解析Json123456//解析Json void ParsJson() &#123; Persons newPersons = JsonUtility.FromJson&lt;Persons&gt;(jsonStr); print(newPersons.persons[0].name); &#125; 2.1LitJson第一种创建和解析方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061using LitJson;public class Hero&#123; public string name; public int age; public string gender;&#125;public class Heros&#123; public Hero[] heros;&#125;public class LitJsonDemo : MonoBehaviour &#123; /*&#123;"heros": [ &#123; "name" : "lisi", "age" : 18, "gender" : "boy" &#125;, &#123; "name" : "zhangsan", "age" : 22, "gender" : "boy" &#125; ] &#125; */ //第一种方法 void Function01() &#123; //创建json Hero hero1 = new Hero(); hero1.name = "lisi"; hero1.age = 18; hero1.gender = "boy"; Hero hero2 = new Hero(); hero2.name = "zhangsan"; hero2.age = 22; hero2.gender = "boy"; Heros heros = new Heros(); heros.heros = new Hero[] &#123; hero1, hero2 &#125;; string jsonStr = JsonMapper.ToJson(heros); //解析json Heros newheros = JsonMapper.ToObject&lt;Heros&gt;(jsonStr); print(newheros.heros[0].name); &#125;&#125; 第二种创建和解析方式 第二种创建和解析Json不需要创建类去解析,直接创建,解析就可以`CSpublic class LitJsonDemo : MonoBehaviour { //第二种方法 //这种方法创建Json的时候是不需要创建任何类,直接写就可以了 void Function02() { //创建json //{&quot;name&quot; : &quot;lisi&quot;,&quot;age&quot; : 10} JsonData creatJson = new JsonData();//JsonData既代表[] 也代表{} creatJson.SetJsonType(JsonType.Object);//设置Json的结构类型 可写可不写.不写Json自动识别类型 creatJson[&quot;name&quot;] = &quot;lisi&quot;; creatJson[&quot;age&quot;] = 10; creatJson.ToJson(); /* {“heros”:[ { “name” : “lisi”, “age” : 18, “gender” : “boy” }, { “name” : “zhangsan”, “age” : 22, “gender” : “boy” }]}*/ JsonData herosJson = new JsonData(); JsonData heroJson1 = new JsonData(); heroJson1[“name”] = “lisi”; heroJson1[“age”] = 18; heroJson1[“gender”] = “boy”; JsonData heroJson2 = new JsonData(); heroJson2[&quot;name&quot;] = &quot;zhangsan&quot;; heroJson2[&quot;age&quot;] = 22; heroJson2[&quot;gender&quot;] = &quot;boy&quot;; JsonData heros = new JsonData(); heros.SetJsonType(JsonType.Array); heros.Add(heroJson1); heros.Add(heroJson2); herosJson[&quot;heros&quot;] = heros; print(herosJson.ToJson()); //解析json string srtJson = &quot;{&apos;heros&apos;:[{&apos;name&apos; : &apos;kk&apos;,&apos;age&apos; : 19,&apos;gender&apos;: &apos;bog&apos;},{&apos;name&apos; : &apos;cc&apos;,&apos;age&apos;: 44,&apos;gender&apos; : &apos;boy&apos;}]}&quot;; JsonData herosjd = JsonMapper.ToObject(srtJson); JsonData hers = herosjd[&quot;heros&quot;]; foreach (JsonData heroJd in hers) { print(heroJd[&quot;name&quot;].ToString()); print(heroJd[&quot;age&quot;]); } } }]]></content>
      <categories>
        <category>Json</category>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lua学习之一]]></title>
    <url>%2F2018%2F08%2F04%2FLua%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[UnityAPI_Mathf数学函数]]></title>
    <url>%2F2018%2F08%2F04%2FUnityAPI-Mathf%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[IOS上线权限]]></title>
    <url>%2F2018%2F08%2F04%2FIOS%E4%B8%8A%E7%BA%BF%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[IOS应用上线AppStore权限问题 1.需要打开info-&gt;Custom Ios Target Properties权限:1.1麦克风权限:12key: Privacy - Microphone Usage Descriptionstringval: 是否允许此App使用你的麦克风？ 1.2相机权限:12key: Privacy - Camera Usage Description stringval: 是否允许此App使用你的相机？ 1.3相册权限:12key: Privacy - Photo Library Usage Descriptionstringval: 是否允许此App访问你的媒体资料库？ 1.4通讯录权限:12key: Privacy - Contacts Usage Descriptionstringval: 是否允许此App访问你的通讯录？ 1.5蓝牙权限:12key: Privacy - Bluetooth Peripheral Usage Descriptionstringval: 是否许允此App使用蓝牙？ 1.6语音转文字权限:12key: Privacy - Speech Recognition Usage Descriptionstringval: 是否允许此App使用语音识别？ 1.7日历权限:12key: Privacy - Calendars Usage Descriptionstringval: Privacy - Calendars Usage Description 1.8定位权限:12key: Privacy - Location When In Use Usage Descriptionstringval: 我们需要通过您的地理位置信息获取您周边的相关数据 1.81定位权限:12key: Privacy - Location Always Usage Descriptionstringval: 我们需要通过您的地理位置信息获取您周边的相关数据]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的动态链接库]]></title>
    <url>%2F2018%2F08%2F04%2FMac%E4%B8%8B%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%2F</url>
    <content type="text"><![CDATA[(转载)MAC下的动态链接库原文地址:https://blog.csdn.net/cbbbc/article/details/50319885 动态链接库已成为现代操作系统的基本组成部分，比如Windows下数不清的.DLL文件和臭名昭著的DLL地狱，Linux下成千上万的.so文件。Mac OS X下也有许多动态链接库，他们的扩展名是.dylib。.dylib是Mach-O格式，也就是Mac OS X下的二进制文件格式。Mac OS X提供了一系列工具，用于创建和访问动态链接库。编译器/usr/bin/cc，也就是gcc了，Apple改过的。这个主要还是一个壳，去调用其他的一些部件。当然同时还有/usr/bin/c++，等等。 汇编器/usr/bin/as 链接器/usr/bin/ldMac OS X有个自己的工具，/usr/bin/libtool，来创建动态链接库。这个libtool不是GNU的那个同名的libtool。我记得GNU libtool可以从Fink（http://fink.sf.net）下载，编译后得到glibtool。 下面来看看如何创建动态链接库。首先是生成module文件，也就是.o文件。这跟一般的unix没什么区别。例如cc -c a.c b.c就得到a.o和b.o 可以用ld来合并.o文件，比如ld -r -o c.o a.o b.o这个也没什么特别。 然后可以用libtool来创建动态链接库。libtool -dynamic -o c.dylib a.o b.o（ 这里也可以用libtool -static -o c.a a.o b.o就创建静态库） 如果用gcc直接编译，我记得linux下一般是可以gcc -shared -o c.so a.c b.c而在Mac OS X下需要gcc -dynamiclib -o c.dylib a.c b.c 这往往也是向Mac OS X移植unix程序常出问题的地方。如果用autoconf/automake等工具，出错的几率应该小一些。 接着来看看访问动态链接库的工具。 nm是最常用的，这个用法跟linux下差不多nm c.dylib可以看到导出符号表，等等。 另一个常用的工具是otool，这个是Mac OS X独有的。比如想看看c.dylib的依赖关系otool -L c.dylib 最后说一下我对Framework的理解。Framework是Mac OS X下必不可少的部分，不妨去看看/System/Library/Frameworks/下面，一大堆Framework。Framework是dylib的进一步演化，它把头文件、文档、动态链接库等整合成一个有机的目录，类似一种自描述的方式，这种做法其实在Mac OS X下随处可见。比如应用程序，一般都是一个目录，譬如/Applications/iTunes.app目录对应应用程序iTunes，双击这个目录即开始执行。这种做法和Windows下常见的一个exe/dll打天下很不相同。Framework的创建工具也是libtool，详细用法参考man。]]></content>
      <categories>
        <category>IOS</category>
        <category>MACOS</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程杂谈]]></title>
    <url>%2F2018%2F08%2F04%2F%E7%BC%96%E7%A8%8B%E6%9D%82%E8%B0%88%2F</url>
    <content type="text"><![CDATA[编程杂谈 1.为什么使用面向对象编程:为了让程序更加清晰,把程序中的功能进行模块化划分,每个模块提供特定的功能,而且每个模块都是孤立的,这种模块化编程提供了非常大的多样性,大大增加了代码重用的机会;面向对象编程也叫OOP编程;简单来说面向对象编程就是结构化编程,对程序中的变量结构划分,让编程更清晰; 1.1类的定义:类实际上是创建对象的模板,每个对象都包含数据,并提供了处理和访问数据的方法;类定义了类的每个对象(称为实例)可以包含什么数据和功能 类实际上是创建对象的模板,每个对象都包含数据,并提供了处理和访问数据的方法;类定义了类的每个对象(称为实例)可以包含什么数据和功能 类中的数据和啊函数称为类的成员;数据成员函数成员数据成员:数据成员是包含类的数据–字段,常量和事件的成员;函数成员:函数成员提供了操作类中数据的某些功能(方法,属性,构造函数,xi) 堆区和栈区: 堆区空间比较大,但是读取速度慢; 栈区空间比较小,但是读取速度快; 在C/C++中栈区内存会自动释放,堆区空间要手动申请内存,手动释放内存 栈区的存储特性: 数据只能从栈的顶端插入和删除; 把数据放入栈顶称为入栈; 从栈顶删除数据称为出栈; 先进后出顺序; 堆区的数据可以任意顺序存储和删除; GC垃圾回收机制: 程序在堆区存储了3个对象 后来程序中其中的一个对象不再被程序使用 垃圾回收器发现无主对象并释放它 垃圾收集之后,被释放对象的内存可以被重用 值类型和引用类型: 类型被分为两种: 值类型(整数,bool,struct char double等)和引用类型(string 数组 自定义类 内置类) 值类型只需要一段单独的内存,用于存储实际的数据(单独定义的时候放在栈区) 引用类型需要两段内存: 第一段存储实际数据,在堆区 第二段存储一个引用,指向堆区空间存储的数据的地址 继承: 很多类中都要相似的数据,这些类他们有很多相同的数据,也有不同的,这个时候我们可以使用继承来让这两个类继承自同一个类 实现继承: 表示一个类型派生于一个基类,它用于该基类类型的所有成员字段和函数,在现实继承中,派生类采用基类的每一个函数的实现代码,除非派生类的定义中指定重写某个函数的实现代码.在需要给现有的类型添加功能,或许许多相关的类型共享一组重要的公共功能时,这种类型的继承非常有用 接口继承: 表示一个类慈宁宫只继承了函数的签名,没有继承任何实现代码,在需要指定该类型具有某些可用的特性时,最好使用这种类型的继承; 密封类和密封方法: C#允许把类和方法声明为sealed,对于类,这表示不能继承该类;对于方法表示不能重写该方法;123sealed FinalClass &#123; //ect&#125; 使用密封类和密封方法放置重写某些类导致代码混乱;]]></content>
      <categories>
        <category>C#</category>
        <category>编程杂谈</category>
      </categories>
      <tags>
        <tag>编程杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array/ArrayList]]></title>
    <url>%2F2018%2F08%2F03%2FArray-ArrayList%2F</url>
    <content type="text"><![CDATA[Array/ArrayList/List之间的区别 1.数组: 优点:在内存中是连续的,速度较快,操作简单; 缺点:定义数组时要定义其长度,不够灵活,过长容易造成资源浪费,过段会造成数据存储越界,不方便进行数据的添加,插入,移除;1234int [] i = new int[2];i[0] = 111;i[1] = 222;//赋值i[1] = 123; //修改 2.集合ArrayList: 优点: 命名空间System.Collections下的一部分,大小是动态扩充和收缩,在声明ArrayList对象时不需要指定长度,ArrayList继承了IList接口,可以很方便的进行数据的添加,插入,删除; 缺点:当想集合插入不同类型的数据后(ArrayList将数据当做object存储),在进行数据处理时容易出现类型不匹配的错误,使用时需要进行类型转换处理,存在装箱与拆箱的操作,造成性能的大量损耗; 123456ArrayList list = new ArrayList();list.Add(“aa”);list.Add(123);list[1] = 1;//修改值list.Remove(123);//移除list.RemoveAt(0); (装箱与拆箱:) 12345678910111213装箱:就是想值类型转换为引用类型拆箱:就是将引用类型转换为值类型(拆箱必须是由值类型转换未来的对象类型再转回值类型,只有装过箱的数据才能拆箱)int n = 10;object o = n;//装箱int b = (int)0;//拆箱看两种类型是否发生了装箱或者拆箱,要看这两种类型是否存在继承关系;string str = &quot;123&quot;;int n = Conver.Toint32(str);//string是引用类型,int是值类型,但是他们之间没有发生装箱或者拆箱,没有具有继承关系int n = 10;IComparable i = n;//这里发生了装箱.int32继承自IComparable; 3.泛型List:12345678优点:与集合ArrayList类似,且继承了IList接口,在声明List集合时也要声明集合内部数据的对象类型,避免了装箱和拆箱; List&lt;int&gt; list = new List&lt;int&gt;(); list.Add(123); list[0] = 111;//修改值 list.RemoveAt(0);//移除 如果list.Add(&quot;abc&quot;);//编译器就会报错,避免了类型安全问题与装箱拆箱问题; string和StringBuilder的区别:tring对象时不可变的,包括长度或者其中任何字符都是不可以改变的任何对String的改变,都会引发新的String对象的生成;string str = “aa”;str = str + “bb”;以上代码让人误以为str是能够增加长度的,其实第二句代码是重新创建了一个新的对象,以前的对象被丢弃,被GC垃圾回收器回收 C#中不能使用 new string();创建对象;假如可以以上代码等价于://string str = new string(“aa”);//str = new string(“aa” + “bb”); stringBuilder是可变的,它是专门用于字符串和字符执行动态操作的类:StringBuilder sb = new StringBuilder(“aa”);sb.Append(“bb”);StringBuilder在内部有一个足够常的字符数组用于存放字符串对象当字符串长度没超过字符数组长度时,所以操作都是针对同一个字符数组,当长度超过十,StringBuilder将自动创建一个更长的数组,把原有的数据复制过去;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity截屏]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E6%88%AA%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[Unity截屏 内置API//Application.CaptureScreenshot 这个已经被Unity废弃掉ScreenCapture.CaptureScreenshot//这个代替了上面的 优点：简单，可以快速地截取某一帧的画面、全屏截图 缺点： 1.不能针对摄像机截图 2.定制大小截图不方便 1234void OnMouseDown()&#123; Application.CaptureScreenshot(Application.persistentDataPath + "/CaptureScreenshot.png");&#125; Texture2D.ReadPixels 自定义截图的大小（包括UI）123456789101112131415161718192021222324252627282930313233void OnScreenShot()&#123; //获取当前系统时间 System.DateTime nowTime = System.DateTime.Now; string times = nowTime.ToString(); times = times.Trim(); times = times.Replace("/", "-"); string fileName = "ScreenShot" + times + ".png"; //判断运行的平台 if(Application.platform == RuntimePlatform.Android)&#123; Texture2D texture = new Texture2D(Screen.width, Screen.height, TextureFormat.RGB24, false); texture.ReadPixels(new Rect(0,0,Screen.width,Screen.height),0,0); texture.Apply(); byte[] bytes = texture.EncodeToPNG(); string destination = "/sdcard/DCIM/Screenshots"; if(!Directory.Exists(destination))&#123; Directory.CreateDirectory(destination); &#125; string pathSave = destination + "/" + fileName; File.WriteAllBytes(pathSave,bytes); &#125;&#125; RenderTextures 新建一个Camera,把这个Camera的Mask设置为只渲染UI层,然后把Depth设置比主相机值要大; 把UI Mode设置为Spac Camera123456789101112131415161718192021222324252627282930313233343536373839public Camera UICamera;public void OnScreenShot() &#123; System.DateTime now = System.DateTime.Now; string times = now.ToString(); times = times.Trim(); times = times.Replace("/", "-"); string FileName = "ShotIamge" + times + ".png"; if(Application.platform == RuntimePlatform.Android) &#123; RenderTexture renderTexture = new RenderTexture(Screen.width, Screen.height, 1); UICamera.targetTexture = renderTexture; UICamera.Render(); RenderTexture.active = renderTexture; Texture2D texture = new Texture2D(Screen.width, Screen.height, TextureFormat.RGB24, false); texture.ReadPixels(new Rect(0, 0, Screen.width, Screen.height), 0, 0); texture.Apply(); ARCamera.targetTexture = null; RenderTexture.active = null; Destroy(renderTexture); byte[] bytes = texture.EncodeToPNG(); string dist = "sdcard/DCIM/Screenshots"; if (!Directory.Exists(dist)) &#123; Directory.CreateDirectory(dist); &#125; string PathSave = dist + "/" + FileName; File.WriteAllBytes(PathSave, bytes); &#125; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协程]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%8D%8F%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Unity协程 Invoke延迟执行123456781.invoke(function_Name,time); 第一为为无参函数,第二个为执行时间 2.invokeRpeating(function_Namem,frist_time,time); 无参函数名,首次执行时间,执行间隔时间 3.Cancelinvoke(function_Name);//取消延迟函数 如果不写参数则取消所有invoke函数 Coroutine 协程是一个分部执行的方法,遇到条件(yield return)会挂起,知道条件满足才继续执行后面的代码 协程其实就是一个IEnumerator(迭代器) 协程和invoke函数最大的不同是可以在执行时添加参数 1234IEnumerator function_Name(parameter,parameter,...)&#123; yield return ....;&#125; 例如: 12345IEnumerator RunTimes(float time)&#123; yield return new WaitForSeconds(time); Debug.Log(" is Run")&#125; 例如参数time = 3f,协程执行遇到yield return语句后就会停止在yield reurn语句位置等待3s后在继续往下面去执行 开启协程: 1StartCoroutine(协程函数名()); 停止协程: 123451.通过字符串方法可以停止一个协程;2.注意:直接用StopCoroutine直接像StartCoroutine一样里面加方法是不能停止该协程的,通过把协程赋予到变量在控制此变量来停止才能中断此协程;StartCoroutine("function_Name",time);//如果用字符串传参的话可能效率会低一些StopCoroutine("function_Name");StopAllCoroutine();//停止所有这个类中的协程函数]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity解析Text文本]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E8%A7%A3%E6%9E%90Text%E6%96%87%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Unity解析Text文本 Unity中解析Text文本有四种方式:1.TextAsset解析123456public TestAsset loadText;public void LoadText()&#123; string str = loadText.text;&#125; 2.协程加WWW类1234567private IEnumerator Start()&#123; WWW www = new WWW("file://"+Application.dataPath + "/text.text"); yield return www; s = www.text; print(s);&#125; 3.Resources.Load(“text”) as TextAsset;1TextAsset resouse = GameObject.Instantiate (Resources.Load&lt;TextAsset&gt;("1111")) as TextAsset; 4.StreamReader123456private void RendFile()&#123; //StreamReader读取的文件位置是在Application.dataPath+"/../" StreamReader sr = new StreamReader("1111.text"); string str = sr.ReadToEnd();&#125; 1.1 StreamWriter写入文本12345678910//注意:此为覆盖式写入文本private void Start()&#123; TextWriter write_str = new StreamWriter(Path.Combine(Application.dataPath+"/../","1111.text")); string str_flie = "1231231234dsf"; write_str.Write(s); write_str.Flush(); write_str.Close(); AssetDatabase.Refresh();&#125; 1.2123StreamWriter sw = new StreamWriter("111.text",true);sw.WriteLine("name age sex");sw.Close()]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity文件操作路径]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[(转)Unity文件操作路径 原博客地址:https://blog.csdn.net/linxinfa/article/details/51679528 1.1 IOS:1234Application.dataPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/DataApplication.streamingAssetsPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/xxx.app/Data/RawApplication.persistentDataPath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/DocumentsApplication.temporaryCachePath : Application/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/Library/Caches 1.2 Android:1234Application.dataPath : /data/app/xxx.xxx.xxx.apkApplication.streamingAssetsPath : jar:file:///data/app/xxx.xxx.xxx.apk/!/assetsApplication.persistentDataPath : /data/data/xxx.xxx.xxx/filesApplication.temporaryCachePath : /data/data/xxx.xxx.xxx/cache 1.3 Windows:1234Application.dataPath : /AssetsApplication.streamingAssetsPath : /Assets/StreamingAssetsApplication.persistentDataPath : C:/Users/xxxx/AppData/LocalLow/CompanyName/ProductNameApplication.temporaryCachePath : C:/Users/xxxx/AppData/Local/Temp/CompanyName/ProductName 1.4 Mac:1234Application.dataPath : /AssetsApplication.streamingAssetsPath : /Assets/StreamingAssetsApplication.persistentDataPath : /Users/xxxx/Library/Caches/CompanyName/Product NameApplication.temporaryCachePath : /var/folders/57/6b4_9w8113x2fsmzx_yhrhvh0000gn/T/CompanyName/Product Name 1.5 Windows Web Player:1234Application.dataPath : file:///D:/MyGame/WebPlayer (即导包后保存的文件夹，html文件所在文件夹)Application.streamingAssetsPath :Application.persistentDataPath :Application.temporaryCachePath : 2.1 文件夹路径2.1 Resources文件夹Resources文件夹是一个只读的文件夹，通过Resources.Load()来读取对象。因为这个文件夹下的所有资源都可以运行时来加载，所以Resources文件夹下的所有东西都会被无条件的打到发布包中。建议这个文件夹下只放Prefab或者一些Object对象，因为Prefab会自动过滤掉对象上不需要的资源。举个例子我把模型文件还有贴图文件都放在了Resources文件夹下，但是我有两张贴图是没有在模型上用的，那么此时这两张没用的贴图也会被打包到发布包中。假如这里我用Prefab，那么Prefab会自动过滤到这两张不被用的贴图，这样发布包就会小一些了。 2.2 StreamingAssetsStreamingAssets文件夹也是一个只读的文件夹，但是它和Resources有点区别，Resources文件夹下的资源会进行一次压缩，而且也会加密，不使用点特殊办法是拿不到原始资源的。但是StreamingAssets文件夹就不一样了，它下面的所有资源不会被加密，然后是原封不动的打包到发布包中，这样很容易就拿到里面的文件。所以StreamingAssets适合放一些二进制文件，而Resources更适合放一些GameObject和Object文件。 StreamingAssets 只能用过www类来读取！！ StreamingAssets，在不同的平台上面 (Windows, Ios ,Android),该目录最终发布的位置不同，所以读取的方法也不同。WWW是异步加载所以执行加载命令式不能直接执行读取解析操作，要等待123WWW www = new WWW(filePath);yield return www; // while (!www.isDone) &#123;&#125;result = www.text; Android之所以不支持C# IO流 方式读取StreamingAssets下的文件，是因为Android手机中 StreamingAssets下的文件 都包含在压缩的.jar文件中（这基本上与标准的zip压缩文件的格式相同）。这意味着，如果你不使用Unity中的WWW类去检索文件，那么你需要使用额外的软件去查看.jar的存档并获取该文件。 安卓上跟其他平台不一样，安装后，这些文件实际上是在一个Jar压缩包里，所以不能直接用读取文件的函数去读，而要用WWW方式。具体做法如下： 1.把你要读取的文件放在Unity项目的Assets/StreamingAssets文件夹下面，没有这个文件夹的话自己建一个。 2.读取的代码(假设名为”文件.txt”)12345678910111213byte[] InBytes; //用来存储读入的数据 if (Application.platform == RuntimePlatform.Android) //判断当前程序是否运行在安卓下 &#123; string FileName = "jar:file://" + Application.dataPath + "!/assets/" + "文件.txt"; WWW www = new WWW(FileName); //WWW会自动开始读取文件 while(!www.isDone)&#123;&#125; //WWW是异步读取，所以要用循环来等待 InBytes = www.bytes; //存到字节数组里 &#125; else &#123; //其他平台的读取代码 &#125; 补充：各目录权限： 根目录：StreamingAssets文件夹1234567#if UNITY_EDITORstring filepath = Application.dataPath +"/StreamingAssets"+"/my.xml";#elif UNITY_IPHONE string filepath = Application.dataPath +"/Raw"+"/my.xml";#elif UNITY_ANDROID string filepath = "jar:file://" + Application.dataPath + "!/assets/"+"/my.xml;#endif 根目录：Resources 文件夹 可以使用Resources.Load(“名字”); 把文件夹中的对象加载出来 根目录：Application.dataPath 文件夹 可以使用Application.dataPath进行读操作 Application.dataPath： 只可读不可写，放置一些资源数据 Application.persistentDataPath IOS与android平台都可以使用这个目录下进行读写操作，可以存放各种配置文件进行修改之类的。 在PC上的地址是：C:\Users\用户名 \AppData\LocalLow\DefaultCompany\test 总结：一.在项目根目录中创建Resources文件夹来保存文件。可以使用Resources.Load(“文件名字，注：不包括文件后缀名”);把文件夹中的对象加载出来。注：此方可实现对文件实施“增删查改”等操作，但打包后不可以更改了。 二.直接放在项目根路径下来保存文件在直接使用Application.dataPath来读取文件进行操作。注：移动端是没有访问权限的。 三.在项目根目录中创建StreamingAssets文件夹来保存文件。1.可使用Application.dataPath来读取文件进行操作。1234567#if UNITY_EDITOR string filepath = Application.dataPath +"/StreamingAssets"+"/my.xml"; #elif UNITY_IPHONE string filepath = Application.dataPath +"/Raw"+"/my.xml"; #elif UNITY_ANDROID string filepath = "jar:file://" + Application.dataPath + "!/assets/"+"/my.xml; #endif 2.直接使用Application.streamingAssetsPath来读取文件进行操作。注：此方法在pc/Mac电脑中可实现对文件实施“增删查改”等操作，但在移动端只支持读取操作。 四.使用Application.persistentDataPath来操作文件（荐）该文件存在手机沙盒中，因为不能直接存放文件，1.通过服务器直接下载保存到该位置，也可以通过Md5码比对下载更新新的资源2.没有服务器的，只有间接通过文件流的方式从本地读取并写入Application.persistentDataPath文件下，然后再通过Application.persistentDataPath来读取操作。 注：在Pc/Mac电脑 以及Android跟Ipad、ipone都可对文件进行任意操作，另外在IOS上该目录下的东西可以被iCloud自动备份]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏设计]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[独立游戏设计 1.什么是游戏 游戏在一个模拟出来的真是环境中,参与者遵照规则行动,尝试完成至少一个既定的重要目标的娱乐活动–Ernest Adms 游戏是一个让玩家在规则约束下参与模拟的冲突,最终产生可量化的结果的系统–Katie Salen 2.游戏的激励要素 游戏的快感激励 快感激励具有 快速即时 普适性强 &amp;&amp; 有衰减性 易于复制 游戏的美感激励 美感激励具有 效果持续 难以复制 &amp;&amp; 隐藏较深 普适性差 分清主次的游戏设计 自由探索与成长 凄美的爱情故事 爽快的战斗 策略与运气 收集与交换 残酷的抉择 策略与操作 3.游戏的系统设计 游戏由规则定义,什么样的规则才是能够吸引玩家的规则 实现机制与渐进机制 实现机制通过设定少量的规则和交互要素,但是通过要素之间的丰富练习和玩家的即时决策创造随机性极大的游戏效果,在这种情况下设计者对于游戏的控制较少,游戏可重复游玩性很高,单局长度往往较短 渐进机制通过完全设定好的流程和大量的规则规划好玩家每个游玩阶段的状态,设计者对于游戏进程控制度很高,游戏重复游玩性差,单局长度往往较长 随机性设计与复杂性设计 随机性的设计更为简单,但是玩家可操控性较差 复杂性的设计较为困难,但是玩家可操控性很强 避免在游戏中出现唯一的最优解 [游戏模拟机制]http://www.jorisdormans.nl/machinations/ 4.游戏的故事设计 游戏的故事有什么作用 作为玩家奖励的一部分 表现游戏世界的背景 提高沉浸感 表达作者的个人情感 共情 玩家与游戏中的角色达到感情上的统一的状态 能够引发共情的情感常常是”人之常情”(爱情,友情,亲情….) 相反,特殊的情感往往难以达到共情的效果,但是却能够给玩家一定的冲击力 按照完整度设计情节 片段情节/完整情节 片段情节适合交代游戏世界的背景 完整情节适合作为玩家的游戏的线索和表达作者情感 完整剧情的叙述可以采用:正叙,倒叙或者混合的方式 完整情节的设计目标: 让玩家了解一个世界 塑造一个或者几个人物 5.独立游戏的制作流程 游戏制作中的分工 制作人 掌控整体框架 沟通者与决策者 策划 内容的设定 细节填充 脚本的制作 美术 人物设定,场景与道具 整体风格把握 程序 实现效果 编写策划工具 音效 音效的采集与制作 音乐的制作 测试 Bug的排查 平台的兼容性 观察与整理测试玩家意见 独行者与合作者 独行者 沟通成本低 有益于坚持设计的理念 对个人要求比较高 合作者 沟通成本较高 需要达成设计的共识 对个人要求较低 6.独立游戏制作技巧 独立游戏与商业游戏 商业游戏面临的问题 市场喜好,发行时机,成本预算与收益估计 独立游戏面临的问题 是否能够有足够的完成度和足够多的可玩内容 是否在制作一半的时候失去动力 是否会建立一个完全无法完成的任务]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity插件之二维码]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E6%8F%92%E4%BB%B6%E4%B9%8B%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Unity之二维码生成与解码 草料二维码网址:https://cli.im/二维码生成网站 (ZXing库) ZXxing是一个开源的,用java实现的多种格式的1D/2D条码图像处理库,它包含了联系其他语言的端口,ZXing可以实现使用手机的内置的摄像头完成条形码的扫描及解码 ZXing下载地址:https://github.com/micjahn/ZXing.Net 把 [zxing.unity.dll] 文件导入到Unity工程中 1.1 识别二维码123456789101112131415161718192021222324252627282930313233//打开相机public RawImage cameraImage; //获取相机贴图 private WebCamTexture webcameraTexture; //ZXing类的中的识别条形码的类 BarcodeReader barcodeReader; Color32[] data; void OpenCamera() &#123; //获取的设备,打开摄像头 WebCamDevice[] device = WebCamTexture.devices; string deviceName = device[0].name; webcameraTexture = new WebCamTexture(deviceName, 400, 300); cameraImage.texture = webcameraTexture; webcameraTexture.Play(); barcodeReader = new BarcodeReader(); Invoke("ScanQRcode",3f); &#125;//把摄像机的画面传递给ZXing库区解析 void ScanQRcode() &#123; //把一张贴图转化为一个颜色数组 data = webcameraTexture.GetPixels32(); var resule = barcodeReader.Decode(data,webcameraTexture.width,webcameraTexture.height); if(resule!= null)&#123; print(resule.Text); &#125; &#125; 1.2生成二维码(这种写法只能填入256 256 有一定局限性)12345678910111213141516171819202122232425262728293031323334353637public RawImage iamge;BarcodeWriter barcodeWriter;private void Update()&#123; if(Input.GetMouseButtonDown(0))&#123; //这种写法只能填入256 256 有一定局限性 ShowQR("666",256,256); &#125;&#125;//显示生成二维码void ShowQR(string str,int width,int height)&#123; //定义Texture2d并填充 Texture2D texture = new Texture2D(width, height); //把Texture2d的内容填充给创建二维码的返回值中 texture.SetPixels32(GeneQRCode(str,width,height)); texture.Apply(); iamge.texture = texture;//在把Texture2d赋值给RawImage&#125;Color32[] GeneQRCode(string formatStr,int width,int height)&#123; ZXing.QrCode.QrCodeEncodingOptions options = new ZXing.QrCode.QrCodeEncodingOptions(); options.CharacterSet = "UTF-8"; options.Width = width; options.Height = height; options.Margin = 1;//二维码距离边缘空白 barcodeWriter = new BarcodeWriter &#123; Format = ZXing.BarcodeFormat.QR_CODE, Options = options &#125;; return barcodeWriter.Write(formatStr);&#125; 2.1摘录大神解决方案(Blog:http://blog.sina.com.cn/s/blog_6ad33d350102xj8l.html)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109using UnityEngine;using System.Collections;using System.Collections.Generic;using ZXing;using ZXing.QrCode;using System;using System.IO;using Timi;// 二维码管理器，功能：1.识别二维码 2：生成二维码public class QRCodeMgr : IManager&#123; private bool m_IsEditorSaveTexture = false; //这里保证上次svn的时候是false，否则每次都要生成新资源 private string QRTextureSavedPath = Application.persistentDataPath + "/QRCodeTexture"; public bool Init() &#123; return true; &#125; //生成二维码 // string text : 需要生成二维码的内容 // Texture2D texture : 二维码生成出来的图片， // string savePath : 保存地址 public Texture2D CreateQRCode(string textForEncoding, int width, int height, bool issave = false) &#123; if (width &gt; 512 &amp;&amp; height &gt; 512) &#123; Debug.LogError("Do not save too big, it will consume cpu performance so much!! "); &#125; string fullpath = QRTextureSavedPath + "/" + textForEncoding + ".png"; //Debug.LogError("fullpath: "+ fullpath); //先判断文件夹下面有没有这个文件 Texture2D encoded = GetAlreadySavePng(fullpath, width, height); if (encoded != null) &#123; return encoded; &#125; else //如果没有要重新创建并视issave保存 &#123; encoded = new Texture2D(width, height); var color32 = Encode2(textForEncoding, width, height); encoded.SetPixels32(color32); encoded.Apply(); if (issave) &#123; if (!Application.isEditor || m_IsEditorSaveTexture) &#123; var bytes = encoded.EncodeToPNG();//把二维码转成byte数组，然后进行输出保存为png图片就可以保存下来生成好的二维码 if (!Directory.Exists(QRTextureSavedPath)) //创建生成目录，如果不存在则创建目录 &#123; //Debug.LogError("CreateDirectory: " + QRTextureSavedPath); Directory.CreateDirectory(QRTextureSavedPath); &#125; System.IO.File.WriteAllBytes(fullpath, bytes); &#125; &#125; &#125; return encoded; &#125; private Texture2D GetAlreadySavePng(string fullpath, int width, int height) &#123; Texture2D ret = null; byte[] bytes = null; if (System.IO.File.Exists(fullpath)) &#123; bytes = System.IO.File.ReadAllBytes(fullpath); if (bytes != null) &#123; ret = new Texture2D(width, height); ret.LoadImage(bytes, true); &#125; &#125; return ret; &#125; private static Color32[] Encode2(string textForEncoding, int width, int height) &#123; ZXing.Common.BitMatrix matrix = new MultiFormatWriter().encode(textForEncoding, BarcodeFormat.QR_CODE, width, height); //注意千万不能使用 writer。。。。因为这个组件除了256 大小能正常输出以外，其他都不支持。。 //texture.LoadImage(ImageToByte(matrix.ToBitmap())); //var writer = new BarcodeWriter(); //return writer.Write(matrix); Color32[] pixels = new Color32[width * height]; // // 下面这里按照二维码的算法，逐个生成二维码的图片， // 两个for循环是图片横列扫描的结果 Color32 black = new Color32(255, 255, 255, 255); Color32 white = new Color32(0, 0, 0, 255); for (int y = 0; y &lt; height; y++) &#123; for (int x = 0; x &lt; width; x++) &#123; if (matrix[x, y]) &#123; pixels[y * width + x] = white;// 0xff000000; &#125; else &#123; pixels[y * width + x] = black;// 0xffffffff; &#125; &#125; &#125; return pixels; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSharpDictionary字典]]></title>
    <url>%2F2018%2F08%2F03%2FCSharpDictionary%E5%AD%97%E5%85%B8%2F</url>
    <content type="text"><![CDATA[C# Dictionary 字典 说明 必须包含名空间System.Collection.Generic Dictionary里面的每一个元素都是一个键值对(由二个元素组成：键和值) 键必须是唯一的,而值不需要唯一的 键和值都可以是任何类型(比如：string, int, 自定义类型，等等) 通过一个键读取一个值的时间是接近O(1) 键值对之间的偏序可以不定义 定义12345678910111213141516171819202122232425262728Dictionary&lt;T, T&gt; openWith = new Dictionary&lt;T, T&gt;();1.常用属性 名称 说明 Comparer 获取用于确定字典中的键是否相等的 IEqualityComparer&lt;T&gt;。 Count 获取包含在 Dictionary&lt;TKey, TValue&gt; 中的键/值对的数目。 Item 获取或设置与指定的键相关联的值。 Keys 获取包含 Dictionary&lt;TKey, TValue&gt; 中的键的集合。 Values 获取包含 Dictionary&lt;TKey, TValue&gt; 中的值的集合。2.常用方法 名称 说明 Add 将指定的键和值添加到字典中。 Clear 从 Dictionary&lt;TKey, TValue&gt; 中移除所有的键和值。 ContainsKey 确定 Dictionary&lt;TKey, TValue&gt; 是否包含指定的键。 ContainsValue 确定 Dictionary&lt;TKey, TValue&gt; 是否包含特定值。 Equals(Object) 确定指定的 Object 是否等于当前的 Object。 （继承自 Object。） Finalize 允许对象在“垃圾回收”回收之前尝试释放资源并执行其他清理操作。 （继承自 Object。） GetEnumerator 返回循环访问 Dictionary&lt;TKey, TValue&gt; 的枚举器。 GetHashCode 用作特定类型的哈希函数。 （继承自 Object。） GetObjectData 实现 System.Runtime.Serialization.ISerializable 接口，并返回序列化 Dictionary&lt;TKey, TValue&gt; 实例所需的数据。 GetType 获取当前实例的 Type。 （继承自 Object。） MemberwiseClone 创建当前 Object 的浅表副本。 （继承自 Object。） OnDeserialization 实现 System.Runtime.Serialization.ISerializable 接口，并在完成反序列化之后引发反序列化事件。 Remove 从 Dictionary&lt;TKey, TValue&gt; 中移除所指定的键的值。 ToString 返回表示当前对象的字符串。 （继承自 Object。） TryGetValue 获取与指定的键相关联的值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859using System;using System.Collections.Generic;public class Example&#123; public static void Main() &#123; //一、创建泛型哈希表，然后加入元素 Dictionary&lt;int, string&gt; oscar = new Dictionary&lt;int, string&gt;(); oscar.Add(1, "BB"); oscar.Add(2, "CC"); oscar.Add(3, "DD"); oscar.Add(4, "EE"); oscar.Add(5, "FF"); //二、删除元素 oscar.Remove(1); //三、假如不存在元素则加入元素 if (!oscar.ContainsKey(1)) oscar.Add(1, "BB"); //四、显然容量和元素个数 Console.WriteLine("元素个数: &#123;0&#125;", oscar.Count); //五、遍历集合 foreach (KeyValuePair&lt;string, string&gt; kvp in oscar) &#123; Console.WriteLine("Index：&#123;0&#125;,Val：&#123;1&#125;", kvp.Key, kvp.Value); &#125; //六、得到哈希表中键的集合 Dictionary&lt;string, string&gt;.KeyCollection keyColl = oscar.Keys; //遍历键的集合 foreach (string s in keyColl) &#123; Console.WriteLine(s); &#125; //七、得到哈希表值的集合 Dictionary&lt;int, string&gt;.ValueCollection valueColl = oscar.Values; //遍历值的集合 foreach (var s in valueColl) &#123; Console.WriteLine(s); &#125; //八、使用TryGetValue方法获取指定键对应的值 string slove = string.Empty; if (oscar.TryGetValue("BB", out slove)) Console.WriteLine("Val&#123;0&#125;", slove); else Console.WriteLine("Not Found Val"); //九、清空哈希表 oscar.Clear(); Console.ReadLine(); &#125;&#125;]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC框架]]></title>
    <url>%2F2018%2F08%2F03%2FMVC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[MVC框架编程 MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。 MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建应用程序的模式： Model（模型）表示应用程序核心（比如数据库记录列表）。 View（视图）显示数据（数据库记录）。 Controller（控制器）处理输入（写入数据库记录）。 Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。 通常模型对象负责在数据库中存取数据。 View（视图）是应用程序中处理数据显示的部分。 通常视图是依据模型数据创建的。 Controller（控制器）是应用程序中处理用户交互的部分。 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。 MVC 分层有助于管理复杂的应用程序，因为您可以在一个时间内专门关注一个方面。例如，您可以在不依赖业务逻辑的情况下专注于视图设计。同时也让应用程序的测试更加容易。MVC 分层同时也简化了分组开发。不同的开发人员可同时开发视图、控制器逻辑和业务逻辑。]]></content>
      <tags>
        <tag>编程大法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CsharpToString]]></title>
    <url>%2F2018%2F08%2F03%2FCsharpToString%2F</url>
    <content type="text"><![CDATA[C#ToString()方法 一、取中文日期显示 1、年月日时分 1currentTime.ToString(&quot;f&quot;); //不显示秒 2、年月 1currentTime.ToString(&quot;y&quot;); 3、月日 1currentTime.ToString(&quot;m&quot;); 4、格式为：2003-9-23 1currentTime.ToString(&quot;d&quot;); 5、格式为：14:24 1currentTime.ToString(&quot;t&quot;); 二、字符型转换 转为字符串123456- 12345.ToString(&quot;n&quot;); //结果：12,345.00- 12345.ToString(&quot;C&quot;); //结果：￥12,345.00- 12345.ToString(&quot;e&quot;); //结果：1.234500e+004- 12345.ToString(&quot;f4&quot;); //结果：12345.0000- 12345.ToString(&quot;x&quot;); //结果：3039 (16进制)- 12345.ToString(&quot;p&quot;); //结果：1,234,500.00% 令DateTime.Now为2007-7-17 22:07:241DateTime.Now.ToString(&quot;yy－MM－dd&quot;) 处理后：07-07-171DateTime.Now.ToString(&quot;yy年MM月dd日&quot;) 处理后：07年07月17日（中文样式） **注：d 月中的某一天。一位数的日期没有前导零。dd 月中的某一天。一位数的日期有一个前导零。 ddd 周中某天的缩写名称，在 AbbreviatedDayNames 中定义。 dddd 周中某天的完整名称，在 DayNames 中定义。 M 月份数字。一位数的月份没有前导零。 MM 月份数字。一位数的月份有一个前导零。 MMM 月份的缩写名称，在 AbbreviatedMonthNames 中定义。 MMMM 月份的完整名称，在 MonthNames 中定义。 y 不包含纪元的年份。如果不包含纪元的年份小于 10，则显示不具有前导零的年份。 yy 不包含纪元的年份。如果不包含纪元的年份小于 10，则显示具有前导零的年份。 yyyy 包括纪元的四位数的年份。 h 12 小时制的小时。一位数的小时数没有前导零。 hh 12 小时制的小时。一位数的小时数有前导零。 H 24 小时制的小时。一位数的小时数没有前导零。 HH 24 小时制的小时。一位数的小时数有前导零。 m 分钟。一位数的分钟数没有前导零。 mm 分钟。一位数的分钟数有一个前导零。 s 秒。一位数的秒数没有前导零。 ss 秒。一位数的秒数有一个前导零。** DateTime技巧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960DateTime.Now.Date.ToShortDateString();//今天DateTime.Now.AddDays(-1).ToShortDateString();//昨天，就是今天的日期减一DateTime.Now.AddDays(1).ToShortDateString();//明天，同理，加一DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek)))).ToShortDateString();//本周(要知道本周的第一天就得先知道今天是星期几，从而得知本周的第一天就是几天前的那一天，要注意的是这里的每一周是从周日始至周六止DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek)))).ToShortDateString();//如果你还不明白，再看一下中文显示星期几的方法就应该懂了//由于DayOfWeek返回的是数字的星期几，我们要把它转换成汉字方便我们阅读，有些人可能会用switch来一个一个地对照，其实不用那么麻烦的 string[] Day = new string[] &#123; "星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六" &#125;;Day[Convert.ToInt16(DateTime.Now.DayOfWeek)];//上周，同理，一个周是7天，上周就是本周再减去7天，下周也是一样DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek))) - 7).ToShortDateString();DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek))) - 7).ToShortDateString();//下周DateTime.Now.AddDays(Convert.ToDouble((0 - Convert.ToInt16(DateTime.Now.DayOfWeek))) + 7).ToShortDateString();DateTime.Now.AddDays(Convert.ToDouble((6 - Convert.ToInt16(DateTime.Now.DayOfWeek))) + 7).ToShortDateString();//本月,很多人都会说本月的第一天嘛肯定是1号，最后一天就是下个月一号再减一天。当然这是对的//一般的写法DateTime.Now.Year.ToString() + DateTime.Now.Month.ToString() + "1"; //第一天DateTime.Parse(DateTime.Now.Year.ToString() + DateTime.Now.Month.ToString() + "1").AddMonths(1).AddDays(-1).ToShortDateString();//最后一天//巧用C#里ToString的字符格式化更简便DateTime.Now.ToString("yyyy-MM-01");DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(1).AddDays(-1).ToShortDateString();//上个月，减去一个月份DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(-1).ToShortDateString();DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddDays(-1).ToShortDateString();//下个月，加去一个月份DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(1).ToShortDateString();DateTime.Parse(DateTime.Now.ToString("yyyy-MM-01")).AddMonths(2).AddDays(-1).ToShortDateString();//7天后DateTime.Now.Date.ToShortDateString();DateTime.Now.AddDays(7).ToShortDateString();//7天前DateTime.Now.AddDays(-7).ToShortDateString();DateTime.Now.Date.ToShortDateString();//本年度，用ToString的字符格式化我们也很容易地算出本年度的第一天和最后一天DateTime.Parse(DateTime.Now.ToString("yyyy-01-01")).ToShortDateString();DateTime.Parse(DateTime.Now.ToString("yyyy-01-01")).AddYears(1).AddDays(-1).ToShortDateString();//上年度，不用再解释了吧DateTime.Parse(DateTime.Now.ToString("yyyy-01-01")).AddYears(-1).ToShortDateString();DateTime.Parse(DateTime.Now.ToString("yyyy-01-01")).AddDays(-1).ToShortDateString();//下年度DateTime.Parse(DateTime.Now.ToString("yyyy-01-01")).AddYears(1).ToShortDateString();DateTime.Parse(DateTime.Now.ToString("yyyy-01-01")).AddYears(2).AddDays(-1).ToShortDateString();//本季度，很多人都会觉得这里难点，需要写个长长的过程来判断。其实不用的，我们都知道一年四个季度，一个季度三个月//首先我们先把日期推到本季度第一个月，然后这个月的第一天就是本季度的第一天了DateTime.Now.AddMonths(0 - ((DateTime.Now.Month - 1) % 3)).ToString("yyyy-MM-01");//同理，本季度的最后一天就是下季度的第一天减一DateTime.Parse(DateTime.Now.AddMonths(3 - ((DateTime.Now.Month - 1) % 3)).ToString("yyyy-MM-01")).AddDays(-1).ToShortDateString();//下季度，相信你们都知道了。。。。收工DateTime.Now.AddMonths(3 - ((DateTime.Now.Month - 1) % 3)).ToString("yyyy-MM-01");DateTime.Parse(DateTime.Now.AddMonths(6 - ((DateTime.Now.Month - 1) % 3)).ToString("yyyy-MM-01")).AddDays(-1).ToShortDateString();//上季度DateTime.Now.AddMonths(-3 - ((DateTime.Now.Month - 1) % 3)).ToString("yyyy-MM-01");DateTime.Parse(DateTime.Now.AddMonths(0 - ((DateTime.Now.Month - 1) % 3)).ToString("yyyy-MM-01")).AddDays(-1).ToShortDateString(); 格式化数值：有时，我们可能需要将数值以一定的格式来呈现，就需要对数值进行格式化。我们使用格式字符串指定格式。格式字符串采用以下形式：Axx，其中 A 为格式说明符，指定格式化类型，xx 为精度说明符，控制格式化输出的有效位数或小数位数。 格式说明符 说明 示例 输出 C 货币 2.5.ToString(“C”) ￥2.50 D 十进制数 25.ToString(“D5”) 00025 E 科学型 25000.ToString(“E”) 2.500000E+005 E 固定点 25.ToString(“F2”) 25.00 G 常规 2.5.ToString(“G”) 2.5 N 数字 2500000.ToString(“N”) 2,500,000.00 X 十六进制 255.ToString(“X”) FF]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity序列化Serialize介绍及用途]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E5%BA%8F%E5%88%97%E5%8C%96Serialize%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[(转)Unity序列化(Serialize)介绍及用途原文链接:https://blog.csdn.net/l773575310/article/details/71774484 什么是序列化 序列化可以用于跨平台。实际上就是把一段数据翻译成（序列化）比较底层的语言（如汇编、机器语言），而基于这个底层语言再可以翻译（反序列化）成多种上一层的语言。 Unity中的序列化 Unity会自动序列化所有你自己写的脚本组件（Scriptable Object）， 重载新的程序集，并且重新创建你的脚本组件。简单的说，序列化后，数据就可以被保存了,Unity序列化过程不走.NET的方法，而是Unity内部的方法。 可序列化类型 1.所有继承至UnityEngine.Object的类，如MonoBehaviour。 2.所有基本数据类型，如int、string等。 3.一些内置类型，如Vector3、Quaternion,、Matrix4x4、Color、Rect、 LayerMask等。 4.一列可序列化类型的列表。 5.枚举类型。 6.结构类型。 Unity可以序列化的有： 1.可序列化类型中公有非静态字段。 2.非公有非静态，但是带[SerializeField] 特性的字段。Unity不可以序列化的有： 1.静态字段 2.属性（Property） 1. 如果一个元素放在list或array两次，序列化时，会得到两份元素的拷贝，而不是一份拷贝两次在新的列表 2.Unity不会序列化字典，但是你可以将key，和value分别存储在list中 参考链接:Unity插件开发基础—浅谈序列化系统 https://zhuanlan.zhihu.com/p/29357313]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FSM状态机之UnityWIKI]]></title>
    <url>%2F2018%2F08%2F03%2FFSM%E7%8A%B6%E6%80%81%E6%9C%BA%E4%B9%8BUnityWIKI%2F</url>
    <content type="text"><![CDATA[FSM有限状态机 组件过渡枚举：此枚举包含可由系统触发的过渡的标签。当FSMSystem类使用它时，不要更改第一个标签NullTransition。 StateID枚举：这是游戏可能拥有的状态的ID。你可以使用对真实国家的类的引用，但使用枚举使系统不太容易让代码访问它不应该访问的对象。所有州的ID都应放在这里。FSMSystem类使用它时不要更改第一个标签NullStateID。 FSMState类：这个类有一个带有对的字典（Transition-StateID），指示当转换T被触发并且当前状态是S1时，FSM应该到达哪个新的状态S2。它有方法来添加和删除对（Transition-StateID），一种方法来检查转移传递给它的状态。在给出的例子中使用了两个方法来检查应该触发哪个转换（Reason（））以及哪个操作（Act（））具有FSMState的GameObject应该执行的操作。您不必使用此架构，但必须在您的游戏中使用某种过渡动作代码。 FSMSystem：这是您的游戏中的每个NPC或GameObject必须具备的有限状态机类才能使用该框架。它将NPC的状态存储在List中，具有添加和删除状态的方法以及基于传递给它的转换（PerformTransition（））更改当前状态的方法。您可以在代码中的任何位置调用此方法，如在碰撞测试中，或在Update（）或FixedUpdate（）中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300using System;using System.Collections;using System.Collections.Generic;using UnityEngine;/**A Finite State Machine System based on Chapter 3.1 of Game Programming Gems 1 by Eric DybsandWritten by Roberto Cezar Bianchini, July 2010How to use: 1. Place the labels for the transitions and the states of the Finite State System in the corresponding enums. 2. Write new class(es) inheriting from FSMState and fill each one with pairs (transition-state). These pairs represent the state S2 the FSMSystem should be if while being on state S1, a transition T is fired and state S1 has a transition from it to S2. Remember this is a Deterministic FSM. You can't have one transition leading to two different states. Method Reason is used to determine which transition should be fired. You can write the code to fire transitions in another place, and leave this method empty if you feel it's more appropriate to your project. Method Act has the code to perform the actions the NPC is supposed do if it's on this state. You can write the code for the actions in another place, and leave this method empty if you feel it's more appropriate to your project. 3. Create an instance of FSMSystem class and add the states to it. 4. Call Reason and Act (or whichever methods you have for firing transitions and making the NPCs behave in your game) from your Update or FixedUpdate methods. Asynchronous transitions from Unity Engine, like OnTriggerEnter, SendMessage, can also be used, just call the Method PerformTransition from your FSMSystem instance with the correct Transition when the event occurs.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSEAND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*//// &lt;summary&gt;/// Place the labels for the Transitions in this enum./// Don't change the first label, NullTransition as FSMSystem class uses it./// &lt;/summary&gt;public enum Transition&#123; NullTransition = 0, // Use this transition to represent a non-existing transition in your system&#125;/// &lt;summary&gt;/// Place the labels for the States in this enum./// Don't change the first label, NullTransition as FSMSystem class uses it./// &lt;/summary&gt;public enum StateID&#123; NullStateID = 0, // Use this ID to represent a non-existing State in your system&#125;/// &lt;summary&gt;/// This class represents the States in the Finite State System./// Each state has a Dictionary with pairs (transition-state) showing/// which state the FSM should be if a transition is fired while this state/// is the current state./// Method Reason is used to determine which transition should be fired ./// Method Act has the code to perform the actions the NPC is supposed do if it's on this state./// &lt;/summary&gt;public abstract class FSMState&#123; protected Dictionary&lt;Transition, StateID&gt; map = new Dictionary&lt;Transition, StateID&gt;(); protected StateID stateID; public StateID ID &#123; get &#123; return stateID; &#125; &#125; public void AddTransition(Transition trans, StateID id) &#123; // Check if anyone of the args is invalid if (trans == Transition.NullTransition) &#123; Debug.LogError("FSMState ERROR: NullTransition is not allowed for a real transition"); return; &#125; if (id == StateID.NullStateID) &#123; Debug.LogError("FSMState ERROR: NullStateID is not allowed for a real ID"); return; &#125; // Since this is a Deterministic FSM, // check if the current transition was already inside the map if (map.ContainsKey(trans)) &#123; Debug.LogError("FSMState ERROR: State " + stateID.ToString() + " already has transition " + trans.ToString() + "Impossible to assign to another state"); return; &#125; map.Add(trans, id); &#125; /// &lt;summary&gt; /// This method deletes a pair transition-state from this state's map. /// If the transition was not inside the state's map, an ERROR message is printed. /// &lt;/summary&gt; public void DeleteTransition(Transition trans) &#123; // Check for NullTransition if (trans == Transition.NullTransition) &#123; Debug.LogError("FSMState ERROR: NullTransition is not allowed"); return; &#125; // Check if the pair is inside the map before deleting if (map.ContainsKey(trans)) &#123; map.Remove(trans); return; &#125; Debug.LogError("FSMState ERROR: Transition " + trans.ToString() + " passed to " + stateID.ToString() + " was not on the state's transition list"); &#125; /// &lt;summary&gt; /// This method returns the new state the FSM should be if /// this state receives a transition and /// &lt;/summary&gt; public StateID GetOutputState(Transition trans) &#123; // Check if the map has this transition if (map.ContainsKey(trans)) &#123; return map[trans]; &#125; return StateID.NullStateID; &#125; /// &lt;summary&gt; /// This method is used to set up the State condition before entering it. /// It is called automatically by the FSMSystem class before assigning it /// to the current state. /// &lt;/summary&gt; public virtual void DoBeforeEntering() &#123; &#125; /// &lt;summary&gt; /// This method is used to make anything necessary, as reseting variables /// before the FSMSystem changes to another one. It is called automatically /// by the FSMSystem before changing to a new state. /// &lt;/summary&gt; public virtual void DoBeforeLeaving() &#123; &#125; /// &lt;summary&gt; /// This method decides if the state should transition to another on its list /// NPC is a reference to the object that is controlled by this class /// &lt;/summary&gt; public abstract void Reason(GameObject player, GameObject npc); /// &lt;summary&gt; /// This method controls the behavior of the NPC in the game World. /// Every action, movement or communication the NPC does should be placed here /// NPC is a reference to the object that is controlled by this class /// &lt;/summary&gt; public abstract void Act(GameObject player, GameObject npc);&#125; // class FSMState/// &lt;summary&gt;/// FSMSystem class represents the Finite State Machine class./// It has a List with the States the NPC has and methods to add,/// delete a state, and to change the current state the Machine is on./// &lt;/summary&gt;public class FSMSystem&#123; private List&lt;FSMState&gt; states; // The only way one can change the state of the FSM is by performing a transition // Don't change the CurrentState directly private StateID currentStateID; public StateID CurrentStateID &#123; get &#123; return currentStateID; &#125; &#125; private FSMState currentState; public FSMState CurrentState &#123; get &#123; return currentState; &#125; &#125; public FSMSystem() &#123; states = new List&lt;FSMState&gt;(); &#125; /// &lt;summary&gt; /// This method places new states inside the FSM, /// or prints an ERROR message if the state was already inside the List. /// First state added is also the initial state. /// &lt;/summary&gt; public void AddState(FSMState s) &#123; // Check for Null reference before deleting if (s == null) &#123; Debug.LogError("FSM ERROR: Null reference is not allowed"); &#125; // First State inserted is also the Initial state, // the state the machine is in when the simulation begins if (states.Count == 0) &#123; states.Add(s); currentState = s; currentStateID = s.ID; return; &#125; // Add the state to the List if it's not inside it foreach (FSMState state in states) &#123; if (state.ID == s.ID) &#123; Debug.LogError("FSM ERROR: Impossible to add state " + s.ID.ToString() + " because state has already been added"); return; &#125; &#125; states.Add(s); &#125; /// &lt;summary&gt; /// This method delete a state from the FSM List if it exists, /// or prints an ERROR message if the state was not on the List. /// &lt;/summary&gt; public void DeleteState(StateID id) &#123; // Check for NullState before deleting if (id == StateID.NullStateID) &#123; Debug.LogError("FSM ERROR: NullStateID is not allowed for a real state"); return; &#125; // Search the List and delete the state if it's inside it foreach (FSMState state in states) &#123; if (state.ID == id) &#123; states.Remove(state); return; &#125; &#125; Debug.LogError("FSM ERROR: Impossible to delete state " + id.ToString() + ". It was not on the list of states"); &#125; /// &lt;summary&gt; /// This method tries to change the state the FSM is in based on /// the current state and the transition passed. If current state /// doesn't have a target state for the transition passed, /// an ERROR message is printed. /// &lt;/summary&gt; public void PerformTransition(Transition trans) &#123; // Check for NullTransition before changing the current state if (trans == Transition.NullTransition) &#123; Debug.LogError("FSM ERROR: NullTransition is not allowed for a real transition"); return; &#125; // Check if the currentState has the transition passed as argument StateID id = currentState.GetOutputState(trans); if (id == StateID.NullStateID) &#123; Debug.LogError("FSM ERROR: State " + currentStateID.ToString() + " does not have a target state " + " for transition " + trans.ToString()); return; &#125; // Update the currentStateID and currentState currentStateID = id; foreach (FSMState state in states) &#123; if (state.ID == currentStateID) &#123; // Do the post processing of the state before setting the new one currentState.DoBeforeLeaving(); currentState = state; // Reset the state to its desired condition before it can reason or act currentState.DoBeforeEntering(); break; &#125; &#125; &#125; // PerformTransition()&#125; //class FSMSystem]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity性能优化篇一]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Unity性能优化篇(一) Unity游戏安装包大/运行卡的原因Mono虚拟机 因为使用Unity在开发游戏的时候,因为Unity是利用Mono虚拟机来实现跨平台.Drawcall 什么是Drawcall: https://www.zhihu.com/question/36357893 其实Drawcall很简单,就是cpu对图形绘制接口的调用,CPU通过调用图形库(directx/opengl)接口,命令GPU进行渲染操作(每一次CPU去调用图形库接口命令GPU渲染即为一次Drawcall) 很多时候我们会误认为是Drawcall造成的性能问题是GPU谢欢渲染状态导致,其实这里的元凶是CPU CPU和GPU是如何进行并行工作和交互的 试想，渲染流程没用采用流水线的工作方式：CPU发送一个渲染命令之后，GPU立即执行渲染命令绘制图形，等到渲染任务结束之后，CPU才可以继续发送下一个渲染命令，这样显然影响工作效率。 采用渲染流水线后，CPU与GPU并行工作，独立而不相互依赖。这是通过命令缓冲区来实现的：命令缓冲区维护一个命令队列，CPU向其中发送命令，GPU从中取出命令并执行。命令有很多种，DrawCall是一种，其他命令还有改变渲染状态、设置渲染数据流等。 这种方式就类似于游戏开发的网络通信：维持一个消息队列，网络线程接收解析消息并将之添加到消息队列，游戏主线程更新时从中取出消息并做派发处理。 DrawCall是如何影响性能的？ 每一次绘制CPU都要调用DrawCall，而在调动DrawCall前，CPU还要进行很多准备工作：检测渲染状态、提交渲染所需要的数据、提交渲染所需要的状态。而GPU本身具有很强大的计算能力，可以很快就处理完渲染任务。 当DrawCall过多，CPU就会很多额外开销用于准备工作，CPU本身负载，而这时GPU可能闲置了。 做个试验：拷贝1000个总大小1M的文件和单个大小为1M的文件，明显拷贝1000个文件要慢很多，DrawCall调用和这个很类似 DrawCall优化：减少DrawCallhttps://zhuanlan.zhihu.com/p/26386905 Unity ProfilerProfilerProfiler官方概述:Unity Profiler窗口可帮助您优化游戏。它会为您报告在游戏的各个区域花了多少时间。例如，它可以报告渲染，动画或游戏逻辑所花时间的百分比。您可以分析GPU，CPU，内存，渲染和音频的性能。要查看性能分析数据，请在编辑器中使用性能分析在游戏中进行游戏，并记录性能数据。Profiler窗口随后在时间轴中显示数据，以便您可以看到比其他帧更快的帧（或更多时间）。通过点击时间线中的任何位置，Profiler窗口的底部将显示所选帧的详细信息。请注意，性能分析必须测试您的代码（即：添加一些说明以方便检查）。虽然这对游戏的性能影响很小，但开销足够小，不会影响游戏帧率https://docs.unity3d.com/2017.4/Documentation/Manual/Profiler.html Unity Statistics统计面板Statistics窗口，全称叫做 Rendering Statistics Window，即渲染统计窗口（或渲染数据统计窗口）,窗口中罗列出关于声音、图像、网络状况等多种统计信息 FPS(Time per frame andFPS):frames per seconds表示引擎处理和渲染一个游戏帧所花费的时间,该数字主要受到场景中渲染物体数量和 GPU性能的影响，FPS数值越高，游戏场景的动画显示会更加平滑和流畅。一般来说，超过30FPS的画面人眼不会感觉到卡，由于视觉残留的特性，光在视网膜上停止总用后人眼还会保持1/24秒左右的时间，因此游戏画面每秒帧数至少要保证在30以上。另外，Unity中的FPS数值仅包括此游戏Scene里更新和渲染的帧，编辑器中绘制的Scene和其它监视窗口的进程不包括在内。 CPU:获取到当前占用CPU进行计算的时间绝对值，或时间点，如果Unity主进程处于挂断或休眠状态时，CPU time将会保持不变。 Render thread:GPU渲染线程处理图像所花费的时间，具体数值由GPU性能来决定， Batches(批处理):即Batched Draw Calls,是Unity内置的Draw Call Batching技术。 解释下什么叫做“Draw call”，CPU每次通知GPU发出一个glDrawElements（OpenGl中的图元渲染函数)或者 DrawIndexedPrimitive（DirectX中的顶点绘制方法）的过程称为一次Draw call,一般来说，引擎每对一个物体进行一次DrawCall，就会产生一个Batch,这个Batch里包含着该物体所有的网格和顶点数据，当渲染另一个相同的物体时，引擎会直接调用Batch里的信息，将相关顶点数据直接送到GPU,从而让渲染过程更加高效，即Batching技术是将所有材质相近的物体进行合并渲染。 对于含有多个不同Shader和Material的物体，渲染的过程比较耗时，因为会产生多个Batches。每次对物体的材质或者贴图进行修改，都会影响Batches里数据集的构成。因此，如果场景中有大量材质不同的物体，会很明显的影响到GPU的渲染效率 Verts：摄像机视野(field of view)内渲染的顶点总数。 Tris: 摄像机视野(field of view)内渲染的的三角面总数量。 Screen:获当前Game屏幕的分辨率大小，后边的2.1MB表示总的内存使用数值。 Shadow casters：表示场景中有多少个可以投射阴影的物体，一般这些物体都作为场景中的光源。 visible skinned meshed：渲染皮肤网格的数量。 Animations:正在播放动画的数量。 SetPass calls: 场景上有1个gameobject，希望能显示很酷炫的效果，它的Material上带有许多特定的Shader。为了实现相应的效果，Shader里或许会包含很多的Pass,每当GPU即将去运行一个Pass之前，就会产生一个“SetPass call”，因此在描述渲染性能开销上，“SetPass calls”更加有说服力https://blog.csdn.net/wdmzjzlym/article/details/51335915 资源优化资源优化标准 对动态模型的面数,材质数量,骨骼数量限定在一定范围之内 对静态模型的顶点数量进行控制 对长短时间音乐的压缩格式选择 对贴图大小选择 对Sharder的运算控制如何减少冗余的资源和重复资源 Resources目录下的资源不管是否被引用,都会打包进安装包,不适用的资源不要放在Resources目录下; 不同目录下的相同资源文件,如果都被引用,那么都会打包进资源包,造成冗余;保证同一个资源文件在项目中只存放在一个目录位置资源监测与分析https://www.uwa4d.com/#assetbundle 使用uwa工具优化安装包大小,和程序运行性能 渲染优化CPU/GPU分工 GPU比较适合大量可并行的简单任务,比如场景渲染,光照处理等,你看到的图像都是显卡渲染出出来的,同时现在的GPU也支持一些其他的运算,比如通过GLSL,HLSL和cg执行并行运算等,GPU同时也对游戏中的一些物理效果提供支持,比如PhysX. 一般CPU用于一些数值运算,逻辑运算,比如伤害,随机数等,同时你的敌人的AI也是CPU运算出来的 LOD-层级细节 层级细节（LOD）全称为Level of Detail。它是根据物体在游戏画面中所占的像素多少（所占游戏视图的百分比）来调用不同复杂度的模型，简单地理解就是同一个物体离摄像机比较远时使用复杂度低的模型，当物体离摄像机比较近时使用复杂度高的模型。这也是一种优化游戏渲染效率的方法。 在第三方建模软件中制作好各个层级（不同复杂程度）的模型。并按照复杂程度自高向低地为模型命名为“模型名字_LOD0”、“模型名字_LOD1”等等，最后的数字序号越低，表示复杂程度越高，这样的命名规则使得Unity3D能够自动为模型添加LOD组（LODGroup） 在导出为FBX之前，需要这两个模型的位置重合，其他的导出设置与普通模型导出一致 把包含了两个层级的FBX模型文件导入到Unity3D之后，Unity3D会根据模型的命名方式自动添加LODGroup。 LOD Group组件 层次细节,它是根据物体在游戏画面中所占视图的百分比来调用不用复杂度的模型,简单来说,就是当一个物体距离相机比较远的时候适用低模,当物体距离相机比较近的时候适用高模,缺点就是占用大量内存. 适用这个技术,一般是在解决运行时流畅的问题,采用的是空间换时间的方式;- 分别将准备好的三种不同精细程度的模型放到LOD Group对应的LOD0/LOD1/LOD2中(LOD0显示的是距离相机最近的时候显示的模型,LOD3显示距离相机较远的时候显示的模型) Occlucion Culling遮挡剔除 遮挡剔除 当场景中势必包含大量的模型时，会造成渲染效率的降低，如果使用遮挡剔除（Occlusion Culling）技术，可以使得那些被阻挡的物体不被渲染，从而达到提高渲染效率的目的。 在默认的渲染管线中也会根据摄像机的视见体的范围对场景模型进行剔除操作，在视见体以外的物体不被渲染，但是在视见体中的物体会以离摄像机最远的物体开始渲染，接着逐渐渲染靠近摄像机的物体，后渲染的物体会覆盖先前渲染的物体，该种技术一般被称为视锥体剔除（Frustum Culling）。 锥体剔除只剔除摄像机视角范围外的物体而对于被包含在视见体中而由被其他物体遮挡的物体还是会进行渲染。而遮挡剔除（Occlusion Culling）技术是同时剔除一个在视见体内但是被其他物体所遮挡住的物体，此时该物体也不会被渲染 使用遮挡剔除时，需要进行手动设置。该技术的基本原理是在场景空间中创建一个遮挡区域，该遮挡区域由单元格（Cell）组成，每个单元格构成了整个场景的遮挡区域的一部分，这些单元格会把整个场景拆分成多个部分。 当摄像机能够看到该单元格时，表示该单元格中的物体会被渲染出来，而被其他单元格挡住的不被摄像机看到的单元格中的物体将不会被渲染。 将所需要进行遮挡剔除的物体全部设置为静态的occ模式 选择Occlusion Cullinghttps://docs.unity3d.com/Manual/OcclusionCulling.htmlhttps://blog.csdn.net/cartzhang/article/details/52684127Lightmapping-光照贴图 减少实时光照,利用光照贴图来节约性能 把需要灯光烘焙的物体勾选上LightMap static 把需要进行灯光烘焙的灯光Model设置为Baked 合并Mesh sharedMesh:当前的mesh conbinerss[i].transfrom: 不是Transfrom组件,转换坐标的矩阵 finalMesh: 合并后的Mesh 渲染途径 Unity 提供不同的渲染途径（Rendering Path）。这些渲染途径用于决定灯光和阴影在场景中的计算方法，不同的渲染途径具有不同的性能特性和渲染效果。 在Unity3D中，提供了三种渲染途径，分别是顶点光照（Vertex Lit）、前向渲染（Forward Rendering）和延时光照（Deferred Lighting） 渲染途径的选择可以通过在Player Settings中来设置，或者为场景中的不同摄像机设置不同的渲染路径，同一个场景中的不同摄像机可以设置不同的渲染途径。 延时光照是具有最高保真度的光照和阴影的渲染途径。如果场景中有很多实时灯光，最好使用延时光照。但它需要一定水平的硬件支持，目前移动设备上不支持该渲染途径。 使用延迟光照的主要优点是对于能影响物体的光线数量没有上限；完全采用以每像素的方式进行光线计算，这等于意味着场景中全部的灯光将以正常的光照模式作用于物体的材质上，从而保证了灯光计算的一致性；所有光线都可以使用灯光Cookie；所有的光线都能产生阴影；光照计算的开销与屏幕的光线尺寸成正比，因此不用担心光线所照射的物品的数量；但是它也有它的缺点，比如没有实时抗锯齿支持；不能处理半透明物体，也不能用在那些使用前向渲染的物体之上；不能取消物体的接受阴影属性（Receive Shadow），也就是说物体将永远接受其他物体所投射的阴影；灯光组件中的Cull Mask属性设置也会失效。 使用延迟光照时需要注意影响它的计算性能的因素：分别是被照亮的物体在屏幕上的像素数量和投射阴影的灯光的数量。延迟光照中实时光线的开销和光线照亮的像素的数量成正比，而不取决于场景的复杂性。 前向渲染路径（Forward Rendering Path）是基于着色器的渲染途径。它支持逐像素计算光照（包括法线贴图和灯光Cookies）以及来自一个平行光的实时阴影。 顶点光照（Vertex Lit） 是最低保真度的光照、不支持实时阴影的渲染路径。支持顶点光照渲染途径只对所有物体渲染一次（或称为一个通道Pass，或者一个渲染阶段），所有光源的照明都是在物体的顶点上进行计算的。这对于需要发布到比较旧的机器上或者受限制的移动平台上是非常合适的。由于顶点光照对硬件要求不高，所以它是最快的渲染途径并且据有最广泛的硬件，但是由于所有的光照都是在顶点层级上计算的，因此此渲染途径不支持大部分的逐像素渲染效果：如阴影、法线贴图、灯光遮罩、高精度的高光。 代码优化 资源池-Object Pooling12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ObjectPool : MonoBehaviour&#123; public static ObjectPool instance; //存储对象池 private static Dictionary&lt;string,ArrayList&gt; pool = new Dictionary&lt;string,ArrayList&gt;&#123;&#125;; void Awake() &#123; instacnce = this; &#125;//从资源池取出数据 public Object GetInstance(string name,Vector3 position,Quaternion rotation) &#123; string key = name+"Clone"; Object obj; //判断是否有该名字的对象池,且对象池对象个数大于0 if(pool.ContainsKey(key) &amp;&amp; pool[key].Count&gt;0) &#123; ArrayList list = pool[key]; obj = list[0] as Object; //从对象池中移除该对象 list.RemoveAt(0); //重新初始化相关状态 (obj as GameObject).SetActive(true); (obj as GameObject).transfrom.position = position; (obj as GameObject).transfrom.rotation = rotation; &#125;else &#123; obj = Instantiate(Resources.Load(name),position,rotation); &#125; //每次把对象从池子里拿出来的时候要初始化对象属性 DelayDestory destory = (obj as GameObject).GetComponent&lt;DelayDestory&gt;().Init(); return obj; &#125;//数据回收到资源池 public Object Return(GameObject obj) &#123; string key = obj.name; //如果这个字典中有这个key的话;判断是否有该对象的对象池 if(pool.ContainsKey(key)) &#123; ArrayList list = pool[key]; //放置到对象池中 list.Add(obj); &#125;else &#123; //创建该类型的池子,将对象放入 pool[key] = new ArrayList()&#123;obj&#125;; &#125; obj.SetActive(false); return obj; &#125;&#125; 123456789101112131415public class DelayDestory : MonoBehaviour&#123; //初始化 public vodi Init() &#123; StartCoroutine(ReturnToPool()); &#125;//2s后自动把对象回收到对象池中 IEnumerator ReturnToPool() &#123; yield return new WaitForSeconds(2f); ObjectPool.instance.Return(this.gameobject); &#125;&#125; 事件调用顺序 在Unity3D的脚本当中，提供了一些按照预定顺序执行的事件函数。熟悉这些事件函数的调用时机，才能把合适的代码放在合适的事件函数中，通过对这些函数进行重写来覆盖默认的函数功能。下图展示了这些事件函数的调用时机。 Awake函数： 也被称为唤醒函数，当一个脚本实例被载入的时候调用，它的调用时机先于Start函数。该方法一般用于游戏开始之前初始化引用或设置游戏状态，与对象构造函数功能相似。该函数在整个脚本的生命周期内只被调用一次，而且它是在场景中所有的对象被实例化之后才被调用，因此可以在该函数中与其他游戏对象进行对话或者使用GameObject中寻找场景对象相关函数如FindWithTag等来寻找场景中的对象，而且一般在该函数中进行脚本或者对象间的引用设置。场景中所有对象脚本中的Awake方法的调用顺序是随机的，也就是说没有按照某种规则先执行哪个对象的Awake函数。这里需要注意的是，Awake函数并不是对象的构造函数，而且不能在该函数中执行协同程序（coroutine）。 Start函数 -称为开始函数，它是在第一次执行Update函数之前，Awake函数执行之后被调用。一般Awake用于初始化对象或者脚本、组件之间的引用，而Start函数用于做数值的初始化设置。而且它同awake一样，在整个脚本生命周期中只被调用一次。在该函数中执行协同程序，用于调整程序执行的节奏，比如等待一个音频素材的导入之后再执行下面的代码等等。 Update函数 也被称为更新函数。该函数游戏运行时每一帧之前被调用一次，是用于更新每帧游戏逻辑数据（比如角色的位置更新）的最常用函数。该函数的调用频率时基于游戏目前的帧速率的，所以其调用频率是由当前游戏的运行速度来决定 LateUpdate函数 更新函数。它在Update函数调用之后被调用，它也是每帧被调用一次。在Update()中执行的任何算都会在LateUpdate()开始之前完成。 LateUpdate()的一个常见应用就是第三人称控制器的相机跟随。如果把角色的移动和旋转放在Update()中，那么就可以把所有相机的移动旋转放在LateUpdate()。这是为了在相机追踪角色位置之前，确保角色已经完成移动 FixedUpdate函数： FixedUpdate()比Update()函数调用的更频繁，它的调用频率是基于整个游戏的固定定时器的。当帧速率较低时，它每帧可能被调用多次，如果帧速率比较高，它有可能就不会被调用了。 所有的物理计算和更新都发生在FixedUpdate()之后。当在FixedUpdate()中计算物体移动时，不需要乘以Time.deltaTime（当然要获得最后一次调用FixedUpdate所用的时间，也可以用Time.deltaTime。）。因为FixedUpdate()是基于可靠的定时器的，不受帧速率的影响。这里需要注意的是，处理Rigidbody相关物理运算时，需要用FixedUpdate来代替Update。例如:给刚体加一个作用力时，必须在FixedUpdate里应用作用力，而不是在Update中，因为物理模拟计算的频率与帧更新的调用频率不同。 OnApplicationFocus函数 也被称为应用程序聚焦函数。现在的操作系统都是多任务多窗口运行系统，也就是说可以同时打开多个应用程序，当前被激活的应用程序也可以成为被聚焦（激活），其他的应用程序失焦。例如现在窗口中打开了网页浏览器，Word，当你激活页面浏览器时，Word就失去焦点，当切换到Word软件时，页面浏览器失焦，而Word软件被激活。当玩家从其他的应用程序聚焦到当前游戏时，OnApplicationFocus函数会被调用。 OnApplicationPause函数: 也被称为应用程序暂停函数。当游戏暂停时在当前帧更新之后被调用。一般是当程序失焦的时候被调用。对于使用Time.scaleTime = 0的方法来暂停游戏，该函数不会被调用。 OnApplicationQuit函数: 也称为应用程序退出函数。在应用退出之前所有的游戏对象都会调用这个函数。当游戏退出时，有可能要对游戏进行一些善后的处理，比如可以在该函数中做数据永久化保存的工作。 游戏对象当前状态的事件函数: 在Unity3D中，游戏对象的状态可以分为实例化、初始化、激活、注销、销毁等。游戏对象的实例化由游戏对象的构造函数来完成，一般的游戏对象其实例化的过程不用人工参与（有时只是为构造函数提供属性值而已），游戏对象实例化之后，其初始化过程由Awake函数和Start函数来完成，而对于激活、注销和销毁等状态，则会分别调用一下四个函数： OnEnable函数，也被称为激活函数。当游戏对象从注销状态转到激活状态时被调用。 OnDisable函数:也被称为注销函数。当游戏对象从激活状态转到注销状态时被调用。 OnDestroy函数： 也被称为对象销毁函数，当场景中的对象被销毁时而且所有帧更新之后被调用（也就是在对象存在的最后一帧）。该函数一般用于相应Destroy函数或者场景关闭时。使用该函数，可以对对象销毁前做善后工作。OnDestroy不能用于协同程序。 Reset函数 也被称为重置函数。Reset是在用户点击Inspector面板的Reset按钮或者首次添加该组件时被调用。此函数只在编辑模式下被调用。Reset最常用于在检视面板中给定一个最常用的默认值 优化工具 UWA Game Optimization Toolkit编译性能优化http://forum.china.unity3d.com/thread-13028-1-1.htmlhttp://gad.qq.com/article/detail/27927 优化运行效率降低绘制调用（Draw Call）数量 随着图形卡性能的提高，处理大量多边形数据的能力也在增长。比如现在一个具有100个三角面的物体和渲染一个具有1500个三角面的物体所需要的渲染开销是差不多的。当处于摄像机视见体内，而且添加了网格渲染器（Mesh Renderer）组件的对象才会产生渲染的开销，而空的游戏对象并不会产生渲染开销。但当模型是分开独立时，从程序把一个模型的数据经过CPU传输到GPU并命令GPU进行绘制时（称为一个Draw Call，也就是绘制调用过程），会产生大量的CPU开销。 Unity3D在运行时可以将一些物体对象进行合并，也就是把多个物体打包再使用一个Draw Call来渲染他们，这一操作被称为“批处理” （Batching） 一般来说，Unity3D批处理的物体越多，便会得到越好的渲染性能。Unity3D中内建的批处理机制所达到的效果要明显强于使用第三方建模软件 使用共享贴图减少Draw Call。Unity3D判断对哪些物体对象进行批处理，一般是根据这些物体是否具有共同的材质和贴图，也就是说，拥有相同材质的物体才可以进行批处理。因此，如果想要得到更好的批处理效果，需要在场景中尽可能地复用材质到不同的物体上。 只合并两个物体而没有共享材质，也是不会启用批处理操作。如果想有效地合并，你需要确保网格结合后，只使用一种材质。 如果需要通过脚本来访问复用材质属性，那么如果使用Renderer.material来改变贴图将会造成一份材质的拷贝。因此，一般应该使用Renderer.sharedMaterial 来保证材质的共享状态。动态批处理 Unity3D内置的批处理对共享贴图的动态物体也同样有效。只是需要注意的地方有：由于批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。 不要使用缩放。分别拥有缩放大小(1,1,1) 和(2,2,2)的两个物体将不会进行批处理。统一缩放的物体不会与非统一缩放的物体进行批处理。 使用不同材质的物体将会不能被批处理。多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染（Forward Rendering）中都支持多个光源，因此为它们开辟多个通道，所以对批处理有影响。使用预设生成的对象会自动地使用相同的网格模型和材质，因此会被批处理。 静态批处理 相对而言，静态批处理操作允许引擎对任意大小的几何物体进行批处理操作来降低绘制调用（只要这些物体不移动，并且拥有相同的材质）。因此，静态批处理比动态批处理更加有效，应该尽量地使用它，因为它需要更少的CPU开销。 为了更好地使用静态批处理，需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。可以通过在Inspector窗口中将Static复选框勾选即可。在前向渲染途径（Forward Rendering Path）模式下减少像素灯的数量根据影响物体的光源的不同，前向渲染途径用单个或多个通道来渲染物体。在前向渲染中，光源本身也会根据他们的设置和强度受到不同级别的对待。使用层消隐距离来优化场景。在一些游戏中，可能需要将小物件剔除，以减少绘图调用的数量。例如，在足够远的距离，大型建筑物仍然可见，小石块和碎片可以隐藏掉。要做到这一点，可以小物件放入一个单独的层（separate layer）中，并使用Camera.layerCullDistances函数来设置每一层的消隐距离。注意阴影的数量和质量如果游戏的发布目标平台是台式机，那么需要注意实时阴影的设置;产生实时阴影一般开销是较大的。如果不正确使用，它们可能造成大量的性能开销。阴影影响渲染速度的主要因素有：产生实时阴影的灯光数量、投射阴影和接收阴影的物体数量（在物体Mesh Renderer组件中设置）、阴影是硬阴影（Hard Shadows，速度快，边缘锐利）还是软阴影（Soft Shadows，速度慢，边缘柔和）、阴影的分辨率以及阴影的柔和度。这些属性基本可以在灯光组件属性面板中设置。如果有需要的话，把一些阴影烘焙在光照贴图上是提高渲染效率的一种方法（此时灯光需要设置成“静态”static物体）。最后还有一个设置可以提高阴影的渲染效率，便是在“质量设置”（Quality Settings）面板中的Shadow Distance属性上设置阴影的显示距离，该距离是根据当前摄像机作为参考的，当可以生成阴影的地方与当前摄像机之间的距离超过该值时，将不生成阴影。优化模型几何体在渲染流水线中，模型的数据量越大，需要对这些数据进行处理的时间也会越长，当然随着渲染技术的发展，处理模型数据的数量也在提升。但是，经量地使用优化的模型可以使得游戏运行更加有效率。那么对模型的优化主要是顶点、三角形面片数目不要太多；使用贴图压缩优化尺寸越小、压缩比率越高的贴图，占用的内存空间也会降低，也可以降低对它的渲染处理时间，同时也会减少游戏文件的体积。修改贴图的尺寸以及压缩格式可以通过贴图的属性面板来设置。最后在整个场景中尽量减少贴图的数量。蒙皮动画模型优化蒙皮动画主要针对添加骨骼的模型，对这些模型的优化也对渲染效率起到不可低估的提升作用。只使用一个蒙皮网格渲染器。在Unity中每个角色仅使用一个蒙皮网格渲染器（skinned mesh renderer）来绘制。 使用尽可能少的材质。应该尽可能地减少网格所用材质的数量。除非想使用不同的着色器来实现不同部位的材质效果（例如，角色身体和眼睛使用不同的着色器）。但是，大多数情况下，每个角色使用2-3个材质就够了 尽可能减少骨骼数量。中型的PC游戏每个角色一般使用15-60个骨骼。骨骼越少，性能越好。一般用30个骨骼就可以在台式机上（Desktop platforms）获得很好的表现效果，同时在手机平台（Mobile Platforms）上质量也相当不错。理想的情况是，在手机平台（Mobile Platforms）上单角色的骨骼不要超过30个，在台式机（ Desktop platforms）上也尽量只用30个左右的骨骼。物理性能优化如果对于台式机，对于稍微复杂一些的物理模拟运算来说是绰绰有余的，但是如果是开发移动终端的游戏，那么就需要更加注意物理性能的优化了。 调整“固定时钟步调”（Fixed Timestep，该时间间隔与帧速率无关，用于控制物理计算和执行FixedUpdate事件的频率）设置（Time manager，在主菜单中选择【Edit】-&gt;【Project Settings】-&gt;【Time】。 这里顺便介绍一下，在这个面板中的最后一个属性“时间缩放因子”（Time Scale），如果该值为1，表示按照正常时钟运行游戏，当该值为0时，游戏暂停运行，如果设置成2，游戏运行时间将加快两倍，当为0.5时，运行时间减慢到一半），以减少对物理更新所花费的时间。 增加时间步长将减少CPU开销，但物理模拟的精度会下降。通常情况下，为增加速度而降低精度是可以接受的折中方案。设置第二个属性中的“最大允许时钟步调”（Maximum Allowed Timestep，物理计算和FixedUpdate() 执行不会超过该指定的时间）在0.1-0.125范围之内，使得在最坏的情况下封顶物理花费的时间。 网格碰撞盒比基本碰撞盒需要更高的性能开销，因此应该尽量少使用。通过把基本碰撞盒作为物体的子对象，来尽可能地近似网格的形状。子碰撞盒将作为单一复合碰撞盒共同控制其父级的刚体。车轮碰撞盒不是严格意义上的固体物体的碰撞，以及布料模拟，都会造成很高的CPU开销。 物理模拟计算的开销取决于场景中非休眠刚体和碰撞盒的数量以及碰撞盒的复杂度。在游戏测试运行的时候，可以在场景中使用分析器来跟踪当前有多少个物理物体在起作用 优化脚本性能 减少固定的增量时间。设置fixedTimeStep值在0.04～0.067秒之间（也就是每秒15～25帧之间）。这降低了FixedUpdate被调用和物理引擎执行碰撞检测和刚体更新的频率。如果为主角色添加了刚体，可以在刚体组件启用“插值”（interpolation）来平滑降低固定增量时间步。 减少GetComponent的调用。使用GetComponent或内置的组件访问函数将带来明显的性能开销。可以通过获取一次组件的引用并指定给变量来避免这个操作（有时也被称为”缓存”的引用）。例如未优化的代码如下： 避免分配内存。除非确实需要，否则应该尽量避免实时生成新的对象，因为当它们不再使用时，为这些废弃的对象进行垃圾回收会造成一定的开销。可以通过使用数组结构来减少垃圾收集。 性能优化文章参考https://blog.csdn.net/candycat1992/article/details/42127811]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity插件之Cinemachine]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E6%8F%92%E4%BB%B6Cinemachine%2F</url>
    <content type="text"><![CDATA[Unity相机插件之Cinemachine 游戏设计中的镜头语言: 跟踪 瞄准 物理相关: 碰撞,视线遮挡 镜头特效 镜头切换 Cinemachine程序化相机系统: 构建虚拟世界的相机系统,模拟真实相机的行为; 通过程序化方式,提高开发效率; Unity官方的教学 Cinemachine提供了很多预先设置好的行为。例如：常见的第三人称绕着角色旋转的行为，或者沿着导轨滑动的行为。通过提前预置行为，可以帮助我们非常方便的来实现游戏中的功能。也就是通过程序化的方式，提升我们的开发效率。 Cinemachine核心组件包括Brain和Virtual Camera（虚拟相机），Brain负责相机的切换。虚拟相机复杂拍摄。 通常我们的场景中不是单一的虚拟摄像机，而是由很多台虚拟相机来完成拍摄任务，如下图所示。因此大家在制作游戏的时候更像是一个电影导演，可以通过各种相机实现各种炫酷的镜头，完成各种不同角度到拍摄。 虚拟相机详解:虚拟相机主要由六个模块组成，分别是： Lens：包括调整FOV等参数； Body：负责处理相机和跟踪目标之间的相对位置的这样一个关系； Aim：负责处理焦点和跟踪目标在镜头中的相对位置； Noise：模拟手持相机的晃动； 后处理模块：让每个镜头有不同的后处理效果； Extnesions可扩展模块：包括碰撞处理等功能。 Body模块，在代码层面称为Transposer，它的主要功能是处理场景中相机和它的目标之间的位置关系。我们可以把它用数学变量表示就是Offset，Offset是一个向量，不仅有大小还有方向。那么Offset的计算方式不同，可以带来不同的跟踪效果。 Transposer的类型目前有五类： Ransposer：基本类型； Obital Transposer：可以根据用户输入绕目标旋转； Framing Tansposer：在屏幕空间中计算相机和目标的Offset; Racked Dolly：把相机设置到一个轨道上； HardLockToTarget：把相机和目标的位置和朝向进行绑定，常用于第一人称模式。Transposer类型。它的参数里面包括了相机和跟踪目标的偏移量，缓动参数，还有绑定的模式。 绑定模式目前是支持六种的绑定模式，大家看到前四种和LockToTarget相关，第五种是WorldSpace，第六种是SimpleFollowWithWorldUp。那么前四种其实它主要的意思是摄像机和目标之间的Offset的计算是以目标为参考系，也就是Offset是在目标的局部空间中，目标转动相机会跟着目标进行旋转，下面这些参数会有一些调整和变化，但是基本上大家理解之后就没有什么问题。WorldSpace则是把Offset放在世界坐标中计算，不会算目标旋转而选择。最后的SimpleFollowWithWorldUp则是把Offset放到相机的坐标系中进行计算。 Obital TransposerObital Transposer能接受用户的输入，并根据这个输入控制相机绕着目标进行旋转，主要是运用在第三人称游戏。由于旋转的时候需要一个基准的方向，而这个方向我们称之为Heading。 Framing Transposer计算屏幕空间中相机和目标的相对位置，常用于2D游戏。 虚拟相机的另一个重要组件Aim在代码层面我们也称之为Composer。其中包含基本类型Composer；Group Composer不是跟踪单一目标，是跟踪群体中的某个位置；然后是POV，类似于第一人称相机的模式，没有具体跟踪到某一个目标，但是根据输入进行自由旋转。然后Hard Look At是锁死某一个目标，然后还有Same As Follow主要是对Follow的目标，保持同样的旋转和朝向。 在Composer中可以设置焦点和目标之间的偏移，追踪目标时候的缓动。在下图中的红色区域我们称之为是DeadZone，当相机和目标距离相对位置超出边界的时候，相机才进行追踪，这也是为了实现一些缓动的效果。那么除此之外还可以设置整个焦点的偏移，我可以把整个相机的焦点区域往任何一个屏幕方向进行偏移。 POV Composer通常和Hard lock To Targt来结合实现第一人称视角相机 Noise组件用于实现相机和目标之间的晃动效果。 Postprocessing组件，每个相机都可以添加一组后处理效果。 扩展组件，有Collider负责相机碰撞检测以及视线遮挡等功能；Confiner负责定义相机的活动范围；FollowZoom动态调整镜头FOV，以便目标在移动的时候会在镜头中保持同样的大小；Story Board是最新的功能，可以在镜头中放置一副参考图，便于摆放位置和调色。 组合虚拟相机介绍Unity提供了种类比较丰富的组合相机，包括：FreeLook，BlendList，State Driven，Dolly Camera，2D Camera等. FreeLookFreeLook可以围绕目标水平和竖直转动，实际上由三个Body组件为Obit Transposer的虚拟相机构成。我们可以利用FreeLook很轻易的实现第三人称相机。 State DrivenState Driven相机可以把动画状态和相机进行绑定，当动画状态切换的时候，相机自动进行切换。 Clear ShotClear Shot相机可以管理一组相机，自动选择进行最佳拍摄的距离。 Target GroupTarget Group相机可以设置相机焦点到多个拍摄目标的中间。比如两个人谈话的时候相机不是对着某个人，而是直接对他们的中间，并且我们可以设置权重调整焦点的偏移。 Cinemachine和TimelineCinemachine提供了Timeline轨道，因此我们可以用Timeline管理场景中的虚拟相机，让虚拟相机更精确的在时间轴上面进行动画的播放以及镜头的混合。 详细的API可以在CinemachinePakge中查看API手册 例子:用Cinemachine作一个在一定范围中跟随角色缓动;12345678910111213141516171819202122using using Cinemachine;/// &lt;summary&gt;/// 设置摄像机的参数与关卡地图匹配/// &lt;/summary&gt;private void ResetCamera()&#123; CinemachineVirtualCamera vCam = GameObject.Find("Vcam").GetComponent&lt;CinemachineVirtualCamera&gt;(); vCam.m_Lens.OrthographicSize = (mapHieght + 3) / 2f; CinemachineFramingTransposer ft = vCam.GetCinemachineComponent(CinemachineCore.Stage.Body) as CinemachineFramingTransposer; ft.m_DeadZoneHeight = (mapHieght * 100) / (300 + mapHieght * 100f); ft.m_DeadZoneWidth = (mapHieght * 100) / (300 + mapHieght * 100f) / 9 * 16 / mapHieght; GetComponent&lt;PolygonCollider2D&gt;().SetPath(0, new Vector2[] &#123; new Vector2(-2f,-2f), new Vector2(-2f,mapHieght+1f), new Vector2(mapWeight+1f,mapHieght+1f), new Vector2(mapWeight+1f,-2f) &#125;); Camera.main.transform.GetChild(0).transform.localPosition = new Vector3(0, vCam.m_Lens.OrthographicSize, 0); ParticleSystem.ShapeModule sm = Camera.main.transform.GetChild(0).GetComponent&lt;ParticleSystem&gt;().shape; sm.scale = new Vector3(vCam.m_Lens.OrthographicSize * 35.5f / 10, 1, 1);&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ShardSDK集成]]></title>
    <url>%2F2018%2F08%2F03%2FShardSDK%E9%9B%86%E6%88%90%2F</url>
    <content type="text"><![CDATA[ShareSDK集成http://www.mob.com/ hareSDK是一种社会化分享组件，为iOS、Android、WP8 的APP提供社会化功能，集成了一些常用的类库和接口，缩短开发者的开发时间，还有社会化统计分析管理后台 支持包括QQ、微信、新浪微博、腾讯微博、开心网、人人网、豆瓣、网易微博、搜狐微博、facebook、twitter、google+等国内外40多家的主流社交平台，帮助开发者轻松实现社会化分享、登录、关注、获得用户资料、获取好友列表等主流的社会化功能，强大的统计分析管理后台，可以实时了解用户、信息流、回流率、传播效率等数据，有效地指导移动APP的日常运营与推广，同时为APP引入更多的社会化流量。 官方文档http://wiki.mob.com/android-sharesdk%E5%AE%8C%E6%95%B4%E7%9A%84%E9%9B%86%E6%88%90%E6%96%87%E6%A1%A3/ 新浪微博接入 1.进入Mob开发者后台,添加应用,添加ShaerSDK 2.进入新浪开发者平台,找到移动应用MOBILE,接入移动应用(新浪也有自己的SDK接入),http://open.weibo.com/wiki/%E7%A7%BB%E5%8A%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8E%A5%E5%85%A5 新浪微博移动端接入指南 Android_Java_Demo: 安卓开发Demo包 demokey.keystore: Share官方提供的一个测试证书文件密码12345,也可以自己生成; ShareSDKForUnity3D: Unity-Android开发包 ShareSDKForUnity3DWithEditor: Unity-IOS开发包,在ios打包文件的时候Share会自动删除没有用到的项 初始化ShareSDK12345678910[HideInInspector]public ShareSDK shareSDK;private void Start()&#123; //ShareSDK类的Awake方法中已经初始化过了,此处可以省略初始化步骤 shareSDK = GetComponent&lt;ShareSDK&gt;(); // shareSDK.InitSDK(""); UnityEngine.SceneManagement.SceneManager.LoadScene(1);&#125; 工具类1234567891011121314151617181920public static void WriteFile(string path,string name,string info)&#123; StreamWriter sw; FileInfo io = new FileInfo(path + "/" + name); sw = io.CreateText(); sw.WriteLine(info); sw.Close(); sw.Dispose();&#125;public static string ReadFile(string path,string name)&#123; StreamReader sw; FileInfo io = new FileInfo(path + "/" + name); sw = io.OpenText(); string infos = sw.ReadToEnd(); sw.Close(); sw.Dispose(); return infos;&#125; 平台登录授权操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364using System.Collections;using System.Collections.Generic;using cn.sharesdk.unity3d;using UnityEngine;public class LoginManager : MonoBehaviour &#123; ShareSDK shareSDK; void Start () &#123; shareSDK = ShareSDKManager.instance.shareSDK; //指定授权结果的回调函数 shareSDK.authHandler = OnAuthResultHandler; &#125; public void OnSinaLoginButtonClick() &#123; //检测指定平台是否已经授权 if(shareSDK.IsAuthorized(PlatformType.SinaWeibo) ) &#123; Utility.WriteFile(Application.persistentDataPath, "AuthInfo.dat", shareSDK.GetAuthInfo(PlatformType.SinaWeibo).toJson()); // Utility.MekeToast("用户" + shareSDK.GetAuthInfo(PlatformType.SinaWeibo)["suerName"] + "登录成功"); UnityEngine.SceneManagement.SceneManager.LoadScene(2); &#125;else &#123; //授权指定平台 shareSDK.Authorize(PlatformType.SinaWeibo); &#125; &#125; /// &lt;summary&gt; /// 指定授权结果的回调函数 /// &lt;/summary&gt; /// &lt;param name="reqID"&gt;自动加载id&lt;/param&gt; /// &lt;param name="state"&gt;授权状态&lt;/param&gt; /// &lt;param name="type"&gt;授权平台&lt;/param&gt; /// &lt;param name="data"&gt;返回的数据(本次授权操作用产生的数据)&lt;/param&gt; void OnAuthResultHandler(int reqID, ResponseState state, PlatformType type, Hashtable data) &#123; if(state == ResponseState.Success) &#123; Utility.WriteFile(Application.persistentDataPath,"AuthResult.dat",data.toJson()); //授权成功后通过GetAuthInfo获取授权信息 shareSDK.GetAuthInfo(type); Utility.WriteFile(Application.persistentDataPath, "AuthInfo.dat", shareSDK.GetAuthInfo(PlatformType.SinaWeibo).toJson()); // Utility.MekeToast("用户"+shareSDK.GetAuthInfo(PlatformType.SinaWeibo)["suerName"]+"登录成功"); UnityEngine.SceneManagement.SceneManager.LoadScene(2); &#125;else if(state == ResponseState.Fail) &#123; //授权信息失败时清空指定平台的授权信息 shareSDK.CancelAuthorize(type); // Utility.MekeToast("登录失败"); &#125;else if(state == ResponseState.Cancel) &#123; //授权取消是清空指定平台的授权信息 shareSDK.CancelAuthorize(type); // Utility.MekeToast("登录取消"); &#125; &#125;&#125; 获取用户信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System.Collections;using cn.sharesdk.unity3d;using UnityEngine;using UnityEngine.UI;public class Info : MonoBehaviour &#123; public Text userName; public Text userId; public Image userIcon; private ShareSDK shareSDK; private void Start() &#123; shareSDK = ShareSDKManager.instance.shareSDK; //从实现保存的dat文件中读取用户信息 Hashtable hash = Utility.ReadFile(Application.persistentDataPath, "AuthInfo.dat").hashtableFromJson(); userName.text = hash["userName"].ToString(); userId.text = hash["userID"].ToString(); StartCoroutine(LoadUserIcon(hash["userIcon"].ToString())); shareSDK.showUserHandler = OnGetUserInfoResouleHandler; &#125; IEnumerator LoadUserIcon(string url) &#123; WWW www = new WWW(url); yield return www; if(www.isDone&amp;&amp; www.error==null) &#123; Texture2D texture2d = www.texture; userIcon.sprite = Sprite.Create(texture2d, new Rect(0, 0, texture2d.width, texture2d.height), Vector2.zero); &#125; &#125; public void OnSingleOutButtonClick() &#123; shareSDK.CancelAuthorize(PlatformType.SinaWeibo); UnityEngine.SceneManagement.SceneManager.LoadScene(1); &#125; public void OnDetailButtonClick() &#123; shareSDK.GetUserInfo(PlatformType.SinaWeibo); UnityEngine.SceneManagement.SceneManager.LoadScene(3); &#125; void OnGetUserInfoResouleHandler(int reqID, ResponseState state, PlatformType type, Hashtable data) &#123; if(state == ResponseState.Success) &#123; Utility.WriteFile(Application.persistentDataPath, "userInfo.dat", data.toJson()); Utility.MekeToast("位置:" +Utility.UnicodeToString(data["location"].ToString())); &#125;else if(state == ResponseState.Cancel) &#123; //获取用户详情操作取消 &#125;else if(state == ResponseState.Fail) &#123; //获取用户详情失败 &#125; &#125;&#125; 平台分享123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106using System.Collections;using System.Collections.Generic;using cn.sharesdk.unity3d;using UnityEngine;using UnityEngine.UI;public class PlayManager : MonoBehaviour &#123; ShareSDK shareSDK; public Text text; // Use this for initialization void Start () &#123; shareSDK = ShareSDKManager.instance.shareSDK; shareSDK.getFriendsHandler = GetFriends; shareSDK.shareHandler = OnShareResuleHandler; &#125; public void OnFriendsButtonClick() &#123; // 通过当前登录用户指定平台获取好友列表/一页多少个/第几页 //此接头弃用,目前只能获取好友总数,后面两个参数失效 shareSDK.GetFriendList(PlatformType.SinaWeibo,10,0); &#125; public void OnShareButtonClick() &#123; Application.CaptureScreenshot("Shot.png"); ShareContent content = new ShareContent(); content.SetText("66666"); //分享图片 //SetImagePath用于本地图片,参数为图片路径 //SetImageUrl为网络图片,参数为图片网址 //SetImageArray用于多图片分享,参数为图片网址的string数组.仅支持网络图片,仅支持Android content.SetImagePath(Application.persistentDataPath+"/Shot.png"); content.SetTitle("标题");//标题 content.SetTitleUrl("www.huabandman.top");//网址 content.SetSite("Hus");//站点 //设置分享内容的主要类型 content.SetShareType(ContentType.Image); //平台特异性分享内容设置 ShareContent sinaWeiBo = new ShareContent(); sinaWeiBo.SetText("8888"+"\n新浪"); //在指定平台上,使用第二个参数中的内容覆盖主内容里面的值 content.SetShareContentCustomize(PlatformType.SinaWeibo,sinaWeiBo); //设置不显示的平台(string数组里面填不显示的类型的枚举变量的int值) string[] platfroms = &#123; "5", "7", "9" &#125;; content.SetHidePlatforms(platfroms); //显示分享框 // PlatformType[] type = &#123; PlatformType.QQ, PlatformType.SinaWeibo, PlatformType.WeChat &#125;; //显示分享框,指定显示平台的方法已经弃用,第一个参数传null即可 shareSDK.ShowPlatformList(null,content,100,100); &#125; public void OnSingleOutButtonClick() &#123; shareSDK.CancelAuthorize(PlatformType.SinaWeibo); UnityEngine.SceneManagement.SceneManager.LoadScene(1); &#125; void GetFriends(int reqID, ResponseState state, PlatformType type, Hashtable data)&#123; if(state == ResponseState.Fail) &#123; &#125;else if(state == ResponseState.Success) &#123; Utility.WriteFile(Application.persistentDataPath,"FriendsList.dat",data.toJson()); &#125;else if(state == ResponseState.Cancel) &#123; &#125; &#125; void OnShareResuleHandler(int reqID, ResponseState state, PlatformType type, Hashtable data) &#123; //并非所以平台都会报告正确的状态 if (state == ResponseState.Success) &#123; &#125; else if (state == ResponseState.Cancel) &#123; //获取用户详情操作取消 &#125; else if (state == ResponseState.Fail) &#123; //获取用户详情失败 &#125; &#125;&#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包系统之显示物品简介]]></title>
    <url>%2F2018%2F08%2F03%2F%E8%83%8C%E5%8C%85%E7%B3%BB%E7%BB%9F%E4%B9%8B%E6%98%BE%E7%A4%BA%E7%89%A9%E5%93%81%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[UGUI显示物品简介信息游戏中背包系统中常见的功能,当鼠标移动到某个物品上时,就会显示物品的信息简介 (同常情况下物品的功能不一样,简介也长短不同,所以如果先创建一个Image,再在Image下面创建一个Text组件的话,这样Image不会跟随格式字体长短,多少进行变大变小,会影响有些信息多,或者信息过长的物品的简介的显示) 1.先创建一个Text组件,然后在Text组件上添加Comtent Size Fitter组件,设置Horizontal Fit和Vertical Fit; 2.然后创建一个背景Image,置于Text组件下,作为Text组件的子物体,设置Image的锚点对其Text锚点; 3.赋值Text一份,(注意赋值的Text上也要Comtent Size Fitter组件),置于Text组件下作为子物体第一个Text组件负责根据字体大小,文字多少去调整Image的大小,第二个Text组件才是负责显示信息 4.设置父物体Text组件的中心点,也就是当鼠标移动上去,会在鼠标的哪个地方显示,这个根据自己的需求调整即可; 5.给父类Text添加一个CanvasGroup组件控制显示隐藏,也可以用其他方法 简介信息面板的显示的隐藏123456789101112131415//鼠标进入public void OnPointerEnter(PointerEventData eventData)&#123; if(transform.childCount&gt;0) &#123; string toolTipText = transform.GetChild(0).GetComponent&lt;ItemUI&gt;().item.GetToolTipText(); InventoryManager.instance.ShowToolTip(toolTipText); &#125;&#125;//鼠标退出public void OnPointerExit(PointerEventData eventData)&#123; if (transform.childCount &gt; 0) InventoryManager.instance.HidToolTip();&#125; 1234567891011121314151617181920212223242526272829303132333435363738private Text toolTopText; private Text contentText; private CanvasGroup canvasGroup; private float targetAlpha = 1; public float soomthing = 10; private void Awake() &#123; toolTopText = GetComponent&lt;Text&gt;(); contentText = transform.Find("ContentText").GetComponent&lt;Text&gt;(); canvasGroup = GetComponent&lt;CanvasGroup&gt;(); &#125; private void Update() &#123; if(canvasGroup.alpha != targetAlpha) &#123; canvasGroup.alpha = Mathf.Lerp(canvasGroup.alpha, targetAlpha, soomthing * Time.deltaTime); if(Mathf.Abs(canvasGroup.alpha-targetAlpha)&lt;0.05f) &#123; canvasGroup.alpha = targetAlpha; &#125; &#125; &#125; public void Show(string text) &#123; toolTopText.text = text; contentText.text = text; targetAlpha = 1; &#125; public void Hid() &#123; targetAlpha = 0; &#125; 简介面板跟随鼠标移动123456789101112131415161718//给toolTip设置位置信息public void SetLocalPosition(Vector3 pos)&#123; transform.localPosition = pos;&#125;private void Update()&#123; //如果提示面板是在显示状态,就让它跟随鼠标 if(toolTipIsShow) &#123; Vector2 position; //设置输入的点在画布上的位置 RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.transform as RectTransform,Input.mousePosition,null,out position); toolTip.SetLocalPosition(position);//把转化的位置传递给toolTip &#125;&#125; 富文本显示物品简介面板:在父类中写一个获取物品提示信息的虚函数,在由各个类型物品的子类去重写这个函数1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 得到提示面板应该显示什么内容/// &lt;/summary&gt;/// &lt;returns&gt;The tool tip text.&lt;/returns&gt;public virtual string GetToolTipText()&#123; string color = ""; switch (quality) &#123; case Quality.Artifact: color = "red"; break; case Quality.Common: color = "white"; break; case Quality.Epic: color = "magenta"; break; case Quality.Legendary: color = "oriange"; break; case Quality.Rare: color = "navy"; break; case Quality.Uncommon: color = "lime"; break; &#125; //字符串格式输出(带富文本类型) string text = string.Format("&lt;color=&#123;4&#125;&gt;&#123;0&#125;&lt;/color&gt;\n&lt;size=17&gt;购买价格:&#123;1&#125; 出售价格:&#123;2&#125;&lt;/size&gt;\n&lt;color=yellow&gt;&#123;3&#125;&lt;/color&gt;", Name, BuyPrice, SellPrice, Desctiption, color); return text;&#125;]]></content>
      <categories>
        <category>Unity</category>
        <category>UGUI</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取App Store引用下载地址]]></title>
    <url>%2F2018%2F08%2F03%2F%E8%8E%B7%E5%8F%96AppStore%E5%BC%95%E7%94%A8%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[一般苹果的下载地址都是: https://itunes.apple.com/cn/app/id1253355672?mt=8 如果你的应用上传了AppStore那么就会分配一个id,替换上面的链接的 IDxxxxxxxxx?mt=8 中的 xxxxxxx 就是AppId号s]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FSM有限状态机]]></title>
    <url>%2F2018%2F08%2F03%2FFSM%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[FSM有限状态机 有限状态机基类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 状态机基类/// &lt;/summary&gt;public abstract class FSMState &#123; protected StateID stateId; public StateID ID&#123; get &#123; return stateId; &#125;&#125; protected FSMSystem fsm; protected Dictionary&lt;Transtion, StateID&gt; map = new Dictionary&lt;Transtion, StateID&gt;(); public FSMState(FSMSystem fsm) &#123; this.fsm = fsm; &#125; /// &lt;summary&gt; /// 添加状态 /// &lt;/summary&gt; /// &lt;param name="trans"&gt;状态转换&lt;/param&gt; /// &lt;param name="id"&gt;状态id&lt;/param&gt; public void AddTransition(Transtion trans,StateID id) &#123; if(trans == Transtion.NullTransition) &#123; Debug.LogError("不允许NullTransition"); return; &#125; if(id == StateID.NullStateID) &#123; Debug.LogError("不允许NullId");return; &#125; if(map.ContainsKey(trans)) &#123; Debug.LogError("Transition:"+trans+"已经存在"); &#125; map.Add(trans,id); &#125; /// &lt;summary&gt; /// 删除转换条件 /// &lt;/summary&gt; /// &lt;param name="trans"&gt;Trans.&lt;/param&gt; public void DeletedTransition(Transtion trans) &#123; if(trans == Transtion.NullTransition) &#123; Debug.LogError("不允许NullTransition"); return; &#125; if(!map.ContainsKey(trans)) &#123; Debug.LogError("Transition:"+trans+"不存在在当前Map中"); &#125; map.Remove(trans); &#125; /// &lt;summary&gt; /// 根据状态查看触发了那个状态 /// &lt;/summary&gt; /// &lt;returns&gt;返回触发的状态&lt;/returns&gt; /// &lt;param name="trans"&gt;Trans.&lt;/param&gt; public StateID GetOutPutState(Transtion trans) &#123; if(map.ContainsKey(trans)) &#123; return map[trans]; &#125; return StateID.NullStateID; &#125; /// &lt;summary&gt; /// 进入状态之前要做的事情 /// &lt;/summary&gt; public virtual void DoBeforeEntering()&#123;&#125; /// &lt;summary&gt; /// 离开状态的时候需要做的事情 /// &lt;/summary&gt; public virtual void DoAfterLeving()&#123;&#125; /// &lt;summary&gt; /// 子类必须重写的行为 /// &lt;/summary&gt; public abstract void Act(GameObject npc); /// &lt;summary&gt; /// 判断转换条件 /// &lt;/summary&gt; public abstract void Reason(GameObject npc);&#125;/// &lt;summary&gt;/// 状态转换条件/// &lt;/summary&gt;public enum Transtion&#123; NullTransition,//空的转换条件 SeePlayer, LostPlayer&#125;/// &lt;summary&gt;/// 状态ID/// &lt;/summary&gt;public enum StateID&#123; NullStateID, Patrol, Chase&#125; 有限状态机管理类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596using System.Collections;using System.Collections.Generic;using UnityEngine;/// &lt;summary&gt;/// 状态机管理类/// &lt;/summary&gt;public class FSMSystem&#123; private Dictionary&lt;StateID, FSMState&gt; state = new Dictionary&lt;StateID, FSMState&gt;(); private StateID currentStateId; private FSMState currentState; /// &lt;summary&gt; /// 添加状态 /// &lt;/summary&gt; /// &lt;param name="s"&gt;S.&lt;/param&gt; public void AddState(FSMState s) &#123; if(s== null) &#123; Debug.LogError("FSMState不能为空");return; &#125; if(currentState == null) &#123; currentState = s; currentStateId = s.ID; &#125; if(state.ContainsKey(s.ID)) &#123; Debug.LogError("状态:"+s.ID+"已经存在,不能重复添加");return; &#125; state.Add(s.ID,s); &#125; /// &lt;summary&gt; /// 删除状态 /// &lt;/summary&gt; /// &lt;param name="id"&gt;Identifier.&lt;/param&gt; public void DeteletedState(StateID id) &#123; if(id == StateID.NullStateID) &#123; Debug.LogError("无法删除空状态");return; &#125; if(state.ContainsKey(id)) &#123; Debug.LogError("无法删除空的状态"+id);return; &#125; state.Remove(id); &#125; /// &lt;summary&gt; /// 状态切换 /// &lt;/summary&gt; /// &lt;param name="trans"&gt;切换状态的条件.&lt;/param&gt; public void PerformTransition(Transtion trans) &#123; if(trans == Transtion.NullTransition) &#123; Debug.LogError("无法执行空的转换条件");return; &#125; StateID id = currentState.GetOutPutState(trans); if(id == StateID.NullStateID) &#123; Debug.LogWarning("当前状态"+currentStateId+"无法根据转换条件"+trans+"发生转换");return; &#125; if(state.ContainsKey(id) == false) &#123; Debug.LogError("在状态机不存在状态"+id+"无法转换");return; &#125; FSMState fsmState = state[id]; currentState.DoBeforeEntering(); currentState = fsmState; currentStateId = fsmState.ID; currentState.DoBeforeEntering(); &#125; /// &lt;summary&gt; /// 更新状态 /// &lt;/summary&gt; /// &lt;returns&gt;The update.&lt;/returns&gt; /// &lt;param name="npc"&gt;Npc.&lt;/param&gt; public void Update(GameObject npc) &#123; currentState.Act(npc); currentState.Reason(npc); &#125;&#125;]]></content>
      <categories>
        <category>FSM有限状态机</category>
      </categories>
      <tags>
        <tag>Uniyt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人工智能编程]]></title>
    <url>%2F2018%2F08%2F03%2F%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[群组行为 博客:http://www.red3d.com/cwr/boids/ 群组的三种行为分离计算出某些个物体的中心点然后给出相反的方向 队列计算出物体的平均方向 聚集计算出物体的中心点,然后向中心店移动 感知系统123456789101112131415161718192021222324252627282930public class Solider : MonoBehaviour &#123; //视野距离 public float viewDistance = 5; //视野角度 public float viewAngle = 120; private Transform playerTransfrom; void Start () &#123; playerTransfrom = GameObject.Find("Player").transform; &#125; void Update () &#123; //判断视野距离(是否在视线范围内) if(Vector3.Distance(playerTransfrom.position,transform.position)&lt;= viewDistance) &#123; //获取player的方位向量 Vector3 playerDir = playerTransfrom.position - transform.position; float angle = Vector3.Angle(playerDir,transform.forward); //是否在视野角度范围内 if(angle&lt;=viewAngle/2) &#123; print("Look the player"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渲染与光照]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%85%89%E7%85%A7%2F</url>
    <content type="text"><![CDATA[渲染与光照 环境光对材质的影响Environment Reflections: Resoulution的位数大小影响材质反射环境的清晰度,位数越高,反射环境越清晰,但是消耗性能越大 如果在烘焙灯光时出现的灯光UV不匹配错误时:选中模型/勾上Generate LightMap 建议在PlayerSetting中Other Setting/Color Space中选择线性光照,线性光照光感会更好,如果在运行平台不支持的时候选择Gamma 阴影 如果场景中物体没有产生阴影的时候: Project Setting/QualitySetting/Shadows;是不是选择了Display Shadow 查看模型MeshRender/Cast shadow是否选择on shader是否是透明材质]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展方法]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[扩展方法 我们在做项目的时候有些时候会遇到这种情况，使用别人封装的方法，但是又觉得方法没有自己所需求的，或者不是自己想要得，还有一种情况就是当你去接收别人的项目的时候，需要做修改而不能变动以前代码的时候，可能就需要用到扩展方法，这样既不会改变别人写的代码，又可以加上自己的修改，并为同一实例调用，是一种好用的方; 不过需要注意几点: 类必须是static的,静态类,但是不能继承MonoBehaviour类,静态类不能拓展MonoBehaviour类。 静态类中的方法同样需要是static的; 拓展方法只能在实例中被调用，而不能在类本身内部使用。 传入的参数需要this修饰符,如: public static void SetPosition(this Transfrom trans); 如果写的扩展方法在一个命名空间中,在别的类中使用,需要引用命名空间 拓展方法的定义代码:1234567891011using UnityEngine;using System.Collections;namespace Extends &#123; //注意命名空间 public static class extendTransform &#123; //静态类 public static void SetPositionX(this Transform trans, float x) &#123; //静态方法，注意this的位置 trans.position = new Vector3(x, trans.position.y, trans.position.z); &#125; public static bool HaveZero(this Transform trans) &#123; //可以有返回值 return (trans.position==new Vector3(0,0,0));10 &#125; &#125;&#125; 调用扩展方法 12345678910using UnityEngine;using System.Collections;using Extends; //引入拓展方法命名空间public class Test : MonoBehaviour &#123; public GameObject obj; void Start () &#123; Debug.Log(obj.transform.position); obj.transform.SetPositionX(10); //直接调用方法 &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using UnityEngine; using System.Collections; public static class Extensions &#123; public static void SetPositionX(this Transform t, float newX) &#123; t.position = new Vector3(newX, t.position.y, t.position.z); &#125; public static void SetPositionY(this Transform t, float newY) &#123; t.position = new Vector3(t.position.x, newY, t.position.z); &#125; public static void SetPositionZ(this Transform t, float newZ) &#123; t.position = new Vector3(t.position.x, t.position.y, newZ); &#125; public static float GetPositionX(this Transform t) &#123; return t.position.x; &#125; public static float GetPositionY(this Transform t) &#123; return t.position.y; &#125; public static float GetPositionZ(this Transform t) &#123; return t.position.z; &#125; public static bool HasRigidbody(this GameObject gobj) &#123; return (gobj.rigidbody != null); &#125; public static bool HasAnimation(this GameObject gobj) &#123; return (gobj.animation != null); &#125; public static void SetSpeed(this Animation anim, float newSpeed) &#123; anim[anim.clip.name].speed = newSpeed; &#125; &#125; 调用扩展方法123456789101112131415161718using UnityEngine; using System.Collections; public class Player : MonoBehaviour &#123; void Update () &#123; float currentX = transform.GetPositionX(); transform.SetPositionX(currentX + 5f); if(gameObject.HasRigidbody()) &#123; &#125; if(gameObject.HasAnimation()) &#123; gameObject.animation.SetSpeed(2f); &#125; &#125; &#125;]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Unity优化之GC——合理优化Unity的GC]]></title>
    <url>%2F2018%2F08%2F03%2FUnity%E4%BC%98%E5%8C%96%E4%B9%8BGC%E2%80%94%E2%80%94%E5%90%88%E7%90%86%E4%BC%98%E5%8C%96Unity%E7%9A%84GC%2F</url>
    <content type="text"><![CDATA[Unity优化之GC——合理优化Unity的GC转载:http://www.cnblogs.com/zblade/ 介绍： 在游戏运行的时候，数据主要存储在内存中，当游戏的数据在不需要的时候，存储当前数据的内存就可以被回收以再次使用。内存垃圾是指当前废弃数据所占用的内存，垃圾回收（GC）是指将废弃的内存重新回收再次使用的过程。 Unity中将垃圾回收当作内存管理的一部分，如果游戏中废弃数据占用内存较大，则游戏的性能会受到极大影响，此时垃圾回收会成为游戏性能的一大障碍点。 本文我们主要学习垃圾回收的机制，垃圾回收如何被触发以及如何提GC收效率来提高游戏的性能。 Unity内存管理机制简介 要想了解垃圾回收如何工作以及何时被触发，我们首先需要了解unity的内存管理机制。Unity主要采用自动内存管理的机制，开发时在代码中不需要详细地告诉unity如何进行内存管理，unity内部自身会进行内存管理。这和使用C++开发需要随时管理内存相比，有一定的优势，当然带来的劣势就是需要随时关注内存的增长，不要让游戏在手机上跑“飞”了。 unity的自动内存管理可以理解为以下几个部分：1234567891）unity内部有两个内存管理池：堆内存和堆栈内存。堆栈内存(stack)主要用来存储较小的和短暂的数据，堆内存(heap)主要用来存储较大的和存储时间较长的数据。 2）unity中的变量只会在堆栈或者堆内存上进行内存分配，变量要么存储在堆栈内存上，要么处于堆内存上。 3）只要变量处于激活状态，则其占用的内存会被标记为使用状态，则该部分的内存处于被分配的状态。 4）一旦变量不再激活，则其所占用的内存不再需要，该部分内存可以被回收到内存池中被再次使用，这样的操作就是内存回收。处于堆栈上的内存回收及其快速，处于堆上的内存并不是及时回收的，此时其对应的内存依然会被标记为使用状态。 5) 垃圾回收主要是指堆上的内存分配和回收，unity中会定时对堆内存进行GC操作。 在了解了GC的过程后，下面详细了解堆内存和堆栈内存的分配和回收机制的差别。 堆栈内存分配和回收机制 堆栈上的内存分配和回收十分快捷简单，因为堆栈上只会存储短暂的或者较小的变量。内存分配和回收都会以一种顺序和大小可控制的形式进行。 堆栈的运行方式就像stack: 其本质只是一个数据的集合，数据的进出都以一种固定的方式运行。正是这种简洁性和固定性使得堆栈的操作十分快捷。当数据被存储在堆栈上的时候，只需要简单地在其后进行扩展。当数据失效的时候，只需要将其从堆栈上移除。堆内存分配和回收机制 堆内存上的内存分配和存储相对而言更加复杂，主要是堆内存上可以存储短期较小的数据，也可以存储各种类型和大小的数据。其上的内存分配和回收顺序并不可控，可能会要求分配不同大小的内存单元来存储数据。 堆上的变量在存储的时候，主要分为以下几步：1231）首先，unity检测是否有足够的闲置内存单元用来存储数据，如果有，则分配对应大小的内存单元; 2）如果没有足够的存储单元，unity会触发垃圾回收来释放不再被使用的堆内存。这步操作是一步缓慢的操作，如果垃圾回收后有足够大小的内存单元，则进行内存分配。 3）如果垃圾回收后并没有足够的内存单元，则unity会扩展堆内存的大小，这步操作会很缓慢，然后分配对应大小的内存单元给变量。 堆内存的分配有可能会变得十分缓慢，特别是在需要垃圾回收和堆内存需要扩展的情况下，通常需要减少这样的操作次数。 垃圾回收时的操作 当堆内存上一个变量不再处于激活状态的时候，其所占用的内存并不会立刻被回收，不再使用的内存只会在GC的时候才会被回收。 每次运行GC的时候，主要进行下面的操作：12341）GC会检查堆内存上的每个存储变量; 2）对每个变量会检测其引用是否处于激活状态； 3）如果变量的引用不再处于激活状态，则会被标记为可回收； 4）被标记的变量会被移除，其所占有的内存会被回收到堆内存上。 GC操作是一个极其耗费的操作，堆内存上的变量或者引用越多则其运行的操作会更多，耗费的时间越长。 何时会触发垃圾回收 主要有三个操作会触发垃圾回收：1231） 在堆内存上进行内存分配操作而内存不够的时候都会触发垃圾回收来利用闲置的内存；2） GC会自动的触发，不同平台运行频率不一样；3） GC可以被强制执行。 特别是在堆内存上进行内存分配时内存单元不足够的时候，GC会被频繁触发，这就意味着频繁在堆内存上进行内存分配和回收会触发频繁的GC操作。 GC操作带来的问题在了解GC在unity内存管理中的作用后，我们需要考虑其带来的问题。最明显的问题是GC操作会需要大量的时间来运行，如果堆内存上有大量的变量或者引用需要检查，则检查的操作会十分缓慢，这就会使得游戏运行缓慢。其次GC可能会在关键时候运行，例如在CPU处于游戏的性能运行关键时刻，此时任何一个额外的操作都可能会带来极大的影响，使得游戏帧率下降。 另外一个GC带来的问题是堆内存的碎片划。当一个内存单元从堆内存上分配出来，其大小取决于其存储的变量的大小。当该内存被回收到堆内存上的时候，有可能使得堆内存被分割成碎片化的单元。也就是说堆内存总体可以使用的内存单元较大，但是单独的内存单元较小，在下次内存分配的时候不能找到合适大小的存储单元，这也会触发GC操作或者堆内存扩展操作。 堆内存碎片会造成两个结果，一个是游戏占用的内存会越来越大，一个是GC会更加频繁地被触发。 分析GC带来的问题GC操作带来的问题主要表现为帧率运行低，性能间歇中断或者降低。如果游戏有这样的表现，则首先需要打开unity中的profiler window来确定是否是GC造成。 了解如何运用profiler window，可以参考此处，如果游戏确实是由GC造成的，可以继续阅读下面的内容。 分析堆内存的分配 如果GC造成游戏的性能问题，我们需要知道游戏中的哪部分代码会造成GC，内存垃圾在变量不再激活的时候产生，所以首先我们需要知道堆内存上分配的是什么变量。 分析堆内存的分配如果GC造成游戏的性能问题，我们需要知道游戏中的哪部分代码会造成GC，内存垃圾在变量不再激活的时候产生，所以首先我们需要知道堆内存上分配的是什么变量。 堆内存和堆栈内存分配的变量类型 在Unity中，值类型变量都在堆栈上进行内存分配，其他类型的变量都在堆内存上分配。如果你不知道值类型和引用类型的差别，可以查看此处。 下面的代码可以用来理解值类型的分配和释放,其对应的变量在函数调用完后会立即回收：12345void ExampleFunciton()&#123; int localInt = 5; &#125; 对应的引用类型的参考代码如下，其对应的变量在GC的时候才回收：1234void ExampleFunction()&#123; List localList = new List(); &#125; 利用profiler window 来检测堆内存分配： 我们可以在profier window中检查堆内存的分配操作：在CPU usage分析窗口中，我们可以检测任何一帧cpu的内存分配情况。其中一个选项是GC Alloc，通过分析其来定位是什么函数造成大量的堆内存分配操作。一旦定位该函数，我们就可以分析解决其造成问题的原因从而减少内存垃圾的产生。现在Unity5.5的版本，还提供了deep profiler的方式深度分析GC垃圾的产生。 降低GC的影响的方法 大体上来说，我们可以通过三种方法来降低GC的影响： 123451）减少GC的运行次数； 2）减少单次GC的运行时间； 3）将GC的运行时间延迟，避免在关键时候触发，比如可以在场景加载的时候调用GC 似乎看起来很简单，基于此，我们可以采用三种策略： 123451）对游戏进行重构，减少堆内存的分配和引用的分配。更少的变量和引用会减少GC操作中的检测个数从而提高GC的运行效率。2）降低堆内存分配和回收的频率，尤其是在关键时刻。也就是说更少的事件触发GC操作，同时也降低堆内存的碎片化。3）我们可以试着测量GC和堆内存扩展的时间，使其按照可预测的顺序执行。当然这样操作的难度极大，但是这会大大降低GC的影响。 减少内存垃圾的数量 减少内存垃圾主要可以通过一些方法来减少： 缓存 如果在代码中反复调用某些造成堆内存分配的函数但是其返回结果并没有使用，这就会造成不必要的内存垃圾，我们可以缓存这些变量来重复利用，这就是缓存。 例如下面的代码每次调用的时候就会造成堆内存分配，主要是每次都会分配一个新的数组：12345void OnTriggerEnter(Collider other)&#123; Renderer[] allRenderers = FindObjectsOfType&lt;Renderer&gt;(); ExampleFunction(allRenderers); &#125; 对比下面的代码，只会生产一个数组用来缓存数据，实现反复利用而不需要造成更多的内存垃圾：1234567891011private Renderer[] allRenderers;void Start()&#123; allRenderers = FindObjectsOfType&lt;Renderer&gt;();&#125;void OnTriggerEnter(Collider other)&#123; ExampleFunction(allRenderers);&#125; 不要在频繁调用的函数中反复进行堆内存分配 在MonoBehaviour中，如果我们需要进行堆内存分配，最坏的情况就是在其反复调用的函数中进行堆内存分配，例如Update()和LateUpdate()函数这种每帧都调用的函数，这会造成大量的内存垃圾。我们可以考虑在Start()或者Awake()函数中进行内存分配，这样可以减少内存垃圾。 下面的例子中，update函数会多次触发内存垃圾的产生：1234void Update()&#123; ExampleGarbageGenerationFunction(transform.position.x);&#125; 通过一个简单的改变，我们可以确保每次在x改变的时候才触发函数调用，这样避免每帧都进行堆内存分配：1234567891011private float previousTransformPositionX;void Update()&#123; float transformPositionX = transform.position.x; if(transfromPositionX != previousTransformPositionX) &#123; ExampleGarbageGenerationFunction(transformPositionX); previousTransformPositionX = trasnformPositionX; &#125;&#125; 另外的一种方法是在update中采用计时器，特别是在运行有规律但是不需要每帧都运行的代码中，例如：1234void Update()&#123; ExampleGarbageGeneratiingFunction()&#125; 通过添加一个计时器，我们可以确保每隔1s才触发该函数一次：1234567891011private float timeSinceLastCalled;private float delay = 1f;void Update()&#123; timSinceLastCalled += Time.deltaTime; if(timeSinceLastCalled &gt; delay) &#123; ExampleGarbageGenerationFunction(); timeSinceLastCalled = 0f; &#125;&#125; 通过这样细小的改变，我们可以使得代码运行的更快同时减少内存垃圾的产生。 附： 不要忽略这一个方法，在最近的项目性能优化中，我经常采用这样的方法来优化游戏的性能，很多对于固定时间的事件回调函数中，如果每次都分配新的缓存，但是在操作完后并不释放，这样就会造成大量的内存垃圾，对于这样的缓存，最好的办法就是当前周期回调后执行清除或者标志为废弃。 清除链表 在堆内存上进行链表的分配的时候，如果该链表需要多次反复的分配，我们可以采用链表的clear函数来清空链表从而替代反复多次的创建分配链表。12345void Update()&#123; List myList = new List(); PopulateList(myList); &#125; 通过改进，我们可以将该链表只在第一次创建或者该链表必须重新设置的时候才进行堆内存分配，从而大大减少内存垃圾的产生：1234567private List myList = new List();void Update()&#123; myList.Clear(); PopulateList(myList);&#125; 对象池 即便我们在代码中尽可能地减少堆内存的分配行为，但是如果游戏有大量的对象需要产生和销毁依然会造成GC。对象池技术可以通过重复使用对象来降低堆内存的分配和回收频率。对象池在游戏中广泛的使用，特别是在游戏中需要频繁的创建和销毁相同的游戏对象的时候，例如枪的子弹这种会频繁生成和销毁的对象。 要详细的讲解对象池已经超出本文的范围，但是该技术值得我们深入的研究This tutorial on object pooling on the Unity Learn site对于对象池有详细深入的讲解。 附：对象池技术属于游戏中比较通用的技术，如果有闲余时间，大家可以学习一下这方面的知识。 造成不必要的堆内存分配的因素 我们已经知道值类型变量在堆栈上分配，其他的变量在堆内存上分配，但是任然有一些情况下的堆内存分配会让我们感到吃惊。下面让我们分析一些常见的不必要的堆内存分配行为并对其进行优化。 字符串 在c#中，字符串是引用类型变量而不是值类型变量，即使看起来它是存储字符串的值的。这就意味着字符串会造成一定的内存垃圾，由于代码中经常使用字符串，所以我们需要对其格外小心。 c#中的字符串是不可变更的，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的“加”操作），unity会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾。 我们可以采用以下的一些方法来最小化字符串的影响：12345671）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件，对于不变的部分就设置为类似常量字符串即可，见下面的例子。3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。 在下面的代码中，在Update函数中会进行一个string的操作，这样的操作就会造成不必要的内存垃圾：1234567public Text timerText;private float timer;void Update()&#123; timer += Time.deltaTime; timerText.text = "Time:"+ timer.ToString();&#125; 通过将字符串进行分隔，我们可以剔除字符串的加操作，从而减少不必要的内存垃圾：123456789101112public Text timerHeaderText;public Text timerValueText;private float timer;void Start()&#123; timerHeaderText.text = "TIME:";&#125;void Update()&#123; timerValueText.text = timer.ToString();&#125; Unity函数调用 在代码编程中，当我们调用不是我们自己编写的代码，无论是Unity自带的还是插件中的，我们都可能会产生内存垃圾。Unity的某些函数调用会产生内存垃圾，我们在使用的时候需要注意它的使用。 这儿没有明确的列表指出哪些函数需要注意，每个函数在不同的情况下有不同的使用，所以最好仔细地分析游戏，定位内存垃圾的产生原因以及如何解决问题。有时候缓存是一种有效的办法，有时候尽量降低函数的调用频率是一种办法，有时候用其他函数来重构代码是一种办法。现在来分析unity中常见的造成堆内存分配的函数调用。 在Unity中如果函数需要返回一个数组，则一个新的数组会被分配出来用作结果返回，这不容易被注意到，特别是如果该函数含有迭代器，下面的代码中对于每个迭代器都会产生一个新的数组：1234567void ExampleFunction()&#123; for(int i=0; i &lt; myMesh.normals.Length;i++) &#123; Vector3 normal = myMesh.normals[i]; &#125;&#125; 对于这样的问题，我们可以缓存一个数组的引用，这样只需要分配一个数组就可以实现相同的功能，从而减少内存垃圾的产生：12345678void ExampleFunction()&#123; Vector3[] meshNormals = myMesh.normals; for(int i=0; i &lt; meshNormals.Length;i++) &#123; Vector3 normal = meshNormals[i]; &#125;&#125; 此外另外的一个函数调用GameObject.name 或者 GameObject.tag也会造成预想不到的堆内存分配，这两个函数都会将结果存为新的字符串返回，这就会造成不必要的内存垃圾，对结果进行缓存是一种有效的办法，但是在Unity中都对应的有相关的函数来替代。对于比较gameObject的tag，可以采用GameObject.CompareTag()来替代。 在下面的代码中，调用gameobject.tag就会产生内存垃圾：12345private string playerTag="Player";void OnTriggerEnter(Collider other)&#123; bool isPlayer = other.gameObject.tag == playerTag;&#125; 采用GameObject.CompareTag()可以避免内存垃圾的产生：12345vate string playerTag = "Player";void OnTriggerEnter(Collider other)&#123; bool isPlayer = other.gameObject.CompareTag(playerTag);&#125; 不只是GameObject.CompareTag，unity中许多其他的函数也可以避免内存垃圾的生成。比如我们可以用Input.GetTouch()和Input.touchCount()来代替Input.touches，或者用Physics.SphereCastNonAlloc()来代替Physics.SphereCastAll()。 装箱操作 装箱操作是指一个值类型变量被用作引用类型变量时候的内部变换过程，如果我们向带有对象类型参数的函数传入值类型，这就会触发装箱操作。比如String.Format()函数需要传入字符串和对象类型参数，如果传入字符串和int类型数据，就会触发装箱操作。如下面代码所示：12345void ExampleFunction()&#123; int cost = 5; string displayString = String.Format("Price:&#123;0&#125; gold",cost);&#125; 在Unity的装箱操作中，对于值类型会在堆内存上分配一个System.Object类型的引用来封装该值类型变量，其对应的缓存就会产生内存垃圾。装箱操作是非常普遍的一种产生内存垃圾的行为，即使代码中没有直接的对变量进行装箱操作，在插件或者其他的函数中也有可能会产生。最好的解决办法是尽可能的避免或者移除造成装箱操作的代码。 协程 调用 StartCoroutine()会产生少量的内存垃圾，因为unity会生成实体来管理协程。所以在游戏的关键时刻应该限制该函数的调用。基于此，任何在游戏关键时刻调用的协程都需要特别的注意，特别是包含延迟回调的协程。 yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾，例如：1yield return 0; 由于需要返回0，引发了装箱操作，所以会产生内存垃圾。这种情况下，为了避免内存垃圾，我们可以这样返回：1yield return null; 另外一种对协程的错误使用是每次返回的时候都new同一个变量，例如： 1234while(!isComplete)&#123; yield return new WaitForSeconds(1f);&#125; 我们可以采用缓存来避免这样的内存垃圾产生：12345WaitForSeconds delay = new WaiForSeconds(1f);while(!isComplete)&#123; yield return delay;&#125; 如果游戏中的协程产生了内存垃圾，我们可以考虑用其他的方式来替代协程。重构代码对于游戏而言十分复杂，但是对于协程而言我们也可以注意一些常见的操作，比如如果用协程来管理时间，最好在update函数中保持对时间的记录。如果用协程来控制游戏中事件的发生顺序，最好对于不同事件之间有一定的信息通信的方式。对于协程而言没有适合各种情况的方法，只有根据具体的代码来选择最好的解决办法。 foreach 循环 在unity5.5以前的版本中，在foreach的迭代中都会生成内存垃圾，主要来自于其后的装箱操作。每次在foreach迭代的时候，都会在堆内存上生产一个System.Object用来实现迭代循环操作。在unity5.5中解决了这个问题，比如，在unity5.5以前的版本中，用foreach实现循环：1234567void ExampleFunction(List listOfInts)&#123; foreach(int currentInt in listOfInts) &#123; DoSomething(currentInt); &#125;&#125; 如果游戏工程不能升级到5.5以上，则可以用for或者while循环来解决这个问题，所以可以改为：12345678void ExampleFunction(List listOfInts)&#123; for(int i=0; i &lt; listOfInts.Count; i++) &#123; int currentInt = listOfInts[i]; DoSomething(currentInt); &#125;&#125; 函数引用 函数的引用，无论是指向匿名函数还是显式函数，在unity中都是引用类型变量，这都会在堆内存上进行分配。匿名函数的调用完成后都会增加内存的使用和堆内存的分配。具体函数的引用和终止都取决于操作平台和编译器设置，但是如果想减少GC最好减少函数的引用。 LINQ和常量表达式 由于LINQ和常量表达式以装箱的方式实现，所以在使用的时候最好进行性能测试。 重构代码来减小GC的影响 即使我们减小了代码在堆内存上的分配操作，代码也会增加GC的工作量。最常见的增加GC工作量的方式是让其检查它不必检查的对象。struct是值类型的变量，但是如果struct中包含有引用类型的变量，那么GC就必须检测整个struct。如果这样的操作很多，那么GC的工作量就大大增加。在下面的例子中struct包含一个string，那么整个struct都必须在GC中被检查：1234567public struct ItemData&#123; public string name; public int cost; public Vector3 position;&#125;private ItemData[] itemData; 我们可以将该struct拆分为多个数组的形式，从而减小GC的工作量123private string[] itemNames;private int[] itemCosts;private Vector3[] itemPositions; 另外一种在代码中增加GC工作量的方式是保存不必要的Object引用，在进行GC操作的时候会对堆内存上的object引用进行检查，越少的引用就意味着越少的检查工作量。在下面的例子中，当前的对话框中包含一个对下一个对话框引用，这就使得GC的时候会去检查下一个对象框： 123456789public class DialogData&#123; private DialogData nextDialog; public DialogData GetNextDialog() &#123; return nextDialog; &#125;&#125; 通过重构代码，我们可以返回下一个对话框实体的标记，而不是对话框实体本身，这样就没有多余的object引用，从而减少GC的工作量：12345678public class DialogData&#123; private int nextDialogID; public int GetNextDialogID() &#123; return nextDialogID; &#125;&#125; 当然这个例子本身并不重要，但是如果我们的游戏中包含大量的含有对其他Object引用的object，我们可以考虑通过重构代码来减少GC的工作量。 定时执行GC操作主动调用GC操作 如果我们知道堆内存在被分配后并没有被使用，我们希望可以主动地调用GC操作，或者在GC操作并不影响游戏体验的时候（例如场景切换的时候），我们可以主动的调用GC操作：1System.GC.Collect() 通过主动的调用，我们可以主动驱使GC操作来回收堆内存。 总结 通过本文对于unity中的GC有了一定的了解，对于GC对于游戏性能的影响以及如何解决都有一定的了解。通过定位造成GC问题的代码以及代码重构我们可以更有效的管理游戏的内存。]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
      </tags>
  </entry>
</search>
